/// <reference types="node" />
import { Features, HttpResponseHeader, Rules, RulesVariables, EdgeFunctions } from '../types';
import PropertyContext from './PropertyContext';
import Cache, { CacheConfig } from './Cache';
import CacheKey from './CacheKey';
import Phase from './Phase';
import Mod from './mods/Mod';
import { InterpolationValues } from '../config';
import { Writable } from 'stream';
import { ComputeFn } from '../router/Router';
import LambdaResponse from './LambdaResponse';
import { Device, Location, Variable } from '../router/RouteCriteria';
import LambdaRequest from './LambdaRequest';
export type Operand = number | string | boolean | RulesVariables;
export declare const EQUALS_EXPRESS = "==";
export declare const EQUALS = "===";
export declare const AND = "and";
export declare const OR = "or";
export declare const NOT_EQUALS_EXPRESS = "!=";
export declare const NOT_EQUALS = "!==";
export declare const MATCHES = "=~";
export declare const NOT_MATCHES = "!~";
export declare const GREATER_THAN = ">";
export declare const GREATER_THAN_OR_EQUALS = ">=";
export declare const LESS_THAN = "<";
export declare const LESS_THAN_OR_EQUALS = "<=";
export declare const IN = "in";
export declare const NOT_IN = "not_in";
export interface RequestContextParams {
    request: LambdaRequest;
    response: LambdaResponse;
    propertyContext: PropertyContext;
    rules: Rules[];
    edgeFunctions?: EdgeFunctions;
    cache?: Cache;
    functions: Array<ComputeFn>;
    interpolationValues?: InterpolationValues;
    variables?: {
        [key in Variable]: string;
    };
    location?: {
        [key in Location]: string;
    };
    device?: {
        [key in Device]: string;
    };
    stdout?: Writable;
    stderr?: Writable;
}
export default class RequestContext {
    private readonly request;
    private readonly response;
    readonly cookies: {
        [key: string]: string;
    };
    readonly variables: {
        [key: string]: string | undefined;
    };
    readonly location: {
        [key: string]: string;
    };
    readonly device: {
        [key: string]: string;
    };
    readonly propertyContext: PropertyContext;
    readonly rules: Rules[];
    readonly edgeFunctions?: EdgeFunctions;
    readonly cache?: Cache;
    readonly functions: Array<ComputeFn>;
    readonly interpolationValues?: InterpolationValues;
    useCacheFile: boolean;
    bypassCache: boolean;
    bypassCacheByHonor: boolean;
    revalidate: boolean;
    followRedirects: boolean;
    ignoreUnsatisfiableRanges: boolean;
    executingSimulator: boolean;
    cacheKey: CacheKey;
    cacheConfig?: CacheConfig;
    originResponseStatus: number | undefined;
    revalidation: Promise<void> | null;
    revalidateResponse: LambdaResponse | null;
    /**
     * The order of phases and modules to execute when handling a request
     */
    simulatorPlan: Array<{
        phase: Phase;
        modules: Mod[];
    }>;
    /**
     * The subset of phases and modules to execute when revalidating a stale response
     */
    revalidatePlan: Array<{
        phase: Phase;
        modules: Mod[];
    }>;
    /**
     * The order of phases and modules to execute when handling a first chunk of data
     */
    writeHeadPlan: Array<{
        phase: Phase;
        modules: Mod[];
    }>;
    /**
     * The order of phases and modules to execute when we need to stream a response we already have
     */
    streamPlan: Array<{
        phase: Phase;
        modules: Mod[];
    }>;
    /**
     * The order of phases and modules to execute when handling a app request
     */
    appPlan: Array<{
        phase: Phase;
        modules: Mod[];
    }>;
    /**
     * The stdout writable stream to which the edge functions, if there are such, will write.
     */
    stdout: Writable;
    /**
     * The stderr writable stream to which the edge functions, if there are such, will write.
     */
    stderr: Writable;
    /**
     * The URI path the request had when first received
     */
    private readonly originalPath;
    /**
     * The parsed query string the request had when first received.
     */
    private readonly originalQuery?;
    private readonly originalQueryString?;
    constructor({ request, response, propertyContext, rules, cache, functions, interpolationValues, variables, location, device, stdout, stderr, edgeFunctions, }: RequestContextParams);
    /**
     * Executes all phases of the request lifecycle, applying features based on the configured rules.
     */
    executeSimulator(): Promise<void>;
    /**
     * Processes the request based on EDGIO_SERVERLESS_HINT_HEADER, if present.
     *
     * Multiple hints can be provided, separated by comma - where generally last one will be executed.
     * The exception is redirect, which takes precedence over anything else, as non-compute redirect
     * doesn't hit the compute at all, and only returns location in header back downstream.
     *
     * Multiple hints provide us the flexibility to use compute when the rules arent enough,
     * WITHOUT changing the functionality.
     *
     * Example:
     *  curl -H "x-edg-serverless-hint:compute:0" -v http://127.0.0.1:3000/compute
     *
     * @returns true if a hints were handled, otherwise false
     */
    executeServerless(): Promise<boolean>;
    /**
     * Processes the request based on provided hint.
     * @returns true if a hint was handled, otherwise false
     */
    handleHint(hintWithValue: string): Promise<boolean>;
    private executeApp;
    private executeCompute;
    /**
     * Revalidates a cached response, fetching it from the origin and adding it to the cache if possible.
     */
    executeRevalidate(): Promise<void>;
    /**
     * Function responsible for writing / streaming content back to the user, running relevant mods if needed.
     * We do not care about ending the stream here - that is done after the whole chain processes, in RequestHandler.
     *
     * If called after response has been streamed, does nothing.
     */
    executeStreamResponse(): Promise<void>;
    /**
     * Calls the specified callback for each rule that matches the current state.
     * @param callback
     */
    forEachMatchingRule(callback: (features: Features, index: number) => void): void;
    /**
     * Calls the specified callback for last matching rule.
     * @param callback return true to confirm the match
     */
    forLastMatchingRule(callback: (features: Features) => boolean): void;
    /**
     * Applies the features configured in the rule if the rule matches the request.
     * @param rule The rule to apply
     * @param callback
     */
    private callIfMatched;
    /**
     * Tests if a conditional (if) evaluates to true.
     * @param conditional
     * @returns
     */
    private isTrue;
    /**
     * Evaluates an operands, which may be a constant or RulesVariable instance.
     * @param operand
     * @returns
     */
    private eval;
    /**
     * Evaluates a RulesVariable instance based on the current request and response.
     * @param variable
     * @returns
     */
    private evalVariable;
    getRequest(): LambdaRequest;
    getResponse(): LambdaResponse;
    /**
     * Adds/appends a value to a request header
     * @param feature
     * @param forceAppend
     */
    setRequestHeader(feature: HttpResponseHeader, forceAppend?: boolean): void;
    /**
     * Adds/appends a value to a response header
     * @param feature
     * @package forceAppend
     */
    setResponseHeader(feature: HttpResponseHeader, forceAppend?: boolean): void;
    setHeader(target: LambdaRequest | LambdaResponse, feature: HttpResponseHeader, allowMultiple?: boolean): void;
    /**
     * Summarizes the context of received request.
     */
    summarize(): string;
}
