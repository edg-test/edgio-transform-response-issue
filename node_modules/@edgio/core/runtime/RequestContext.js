"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NOT_IN = exports.IN = exports.LESS_THAN_OR_EQUALS = exports.LESS_THAN = exports.GREATER_THAN_OR_EQUALS = exports.GREATER_THAN = exports.NOT_MATCHES = exports.MATCHES = exports.NOT_EQUALS = exports.NOT_EQUALS_EXPRESS = exports.OR = exports.AND = exports.EQUALS = exports.EQUALS_EXPRESS = void 0;
const cookie_1 = require("cookie");
const toRegExp_1 = __importDefault(require("./toRegExp"));
const CacheKey_1 = __importDefault(require("./CacheKey"));
const first_1 = __importDefault(require("../utils/first"));
const Phase_1 = __importDefault(require("./Phase"));
const ModRewrite_1 = __importDefault(require("./mods/ModRewrite"));
const ModCache_1 = __importDefault(require("./mods/ModCache"));
const ModAccess_1 = __importDefault(require("./mods/ModAccess"));
const ModSetEnv_1 = __importDefault(require("./mods/ModSetEnv"));
const ModProxyCore_1 = __importDefault(require("./mods/ModProxyCore"));
const ModProxyFeatures_1 = __importDefault(require("./mods/ModProxyFeatures"));
const ModRedirect_1 = __importDefault(require("./mods/ModRedirect"));
const log_1 = __importDefault(require("../log"));
const constants_1 = require("../constants");
const origins_1 = require("../origins");
const Origin_1 = __importDefault(require("./Origin"));
const ModEdgeFunctions_1 = __importDefault(require("./mods/ModEdgeFunctions"));
const interpolate_1 = require("./interpolate");
const LambdaResponse_1 = __importDefault(require("./LambdaResponse"));
const toPathRegexp_1 = __importDefault(require("../utils/toPathRegexp"));
const path_1 = __importDefault(require("path"));
const ModTranscode_1 = __importDefault(require("./mods/ModTranscode"));
const ModStream_1 = __importDefault(require("./mods/ModStream"));
const executePlan_1 = __importDefault(require("./executePlan"));
exports.EQUALS_EXPRESS = '==';
exports.EQUALS = '===';
exports.AND = 'and';
exports.OR = 'or';
exports.NOT_EQUALS_EXPRESS = '!=';
exports.NOT_EQUALS = '!==';
exports.MATCHES = '=~';
exports.NOT_MATCHES = '!~';
exports.GREATER_THAN = '>';
exports.GREATER_THAN_OR_EQUALS = '>=';
exports.LESS_THAN = '<';
exports.LESS_THAN_OR_EQUALS = '<=';
exports.IN = 'in';
exports.NOT_IN = 'not_in';
class RequestContext {
    constructor({ request, response, propertyContext, rules, cache, functions, interpolationValues, variables, location, device, stdout, stderr, edgeFunctions, }) {
        this.functions = [];
        this.useCacheFile = false;
        this.bypassCache = false;
        this.bypassCacheByHonor = false;
        this.revalidate = false;
        this.followRedirects = false;
        this.ignoreUnsatisfiableRanges = false;
        this.executingSimulator = false;
        this.originResponseStatus = undefined;
        this.revalidation = null;
        this.revalidateResponse = null;
        /**
         * The stdout writable stream to which the edge functions, if there are such, will write.
         */
        this.stdout = process === null || process === void 0 ? void 0 : process.stdout;
        /**
         * The stderr writable stream to which the edge functions, if there are such, will write.
         */
        this.stderr = process === null || process === void 0 ? void 0 : process.stderr;
        this.request = request;
        this.cacheKey = new CacheKey_1.default(request);
        this.response = response;
        this.propertyContext = propertyContext;
        this.rules = rules;
        this.edgeFunctions = edgeFunctions;
        this.cookies = (0, cookie_1.parse)((0, first_1.default)(request.headers['cookie'] || ''));
        this.variables = variables !== null && variables !== void 0 ? variables : {};
        this.cache = cache;
        this.originalPath = this.request.path;
        this.originalQuery = this.request.query;
        this.originalQueryString = new URL(request.url, 'http://localhost').search;
        this.functions = functions;
        this.interpolationValues = interpolationValues;
        this.stdout = stdout || process.stdout;
        this.stderr = stderr || process.stderr;
        // todo: This is hardcoded value, consider adding an option to override it
        // this is only used in dev mode, we cannot end in execution plan if we are in dev mode
        this.device = device !== null && device !== void 0 ? device : {
            device_os: 'iOS',
            brand_name: 'Apple',
            dual_orientation: 'true',
            html_preferred_dtd: 'html5',
            image_inlining: 'partial',
            is_android: 'false',
            is_app: 'true',
            is_full_desktop: 'false',
            is_html_preferred: 'true',
            is_ios: 'true',
            is_largescreen: 'true',
            is_mobile: 'false',
            is_robot: 'false',
            is_smartphone: 'false',
            is_smarttv: 'false',
            is_tablet: 'false',
            is_touchscreen: 'false',
            is_windows_phone: 'false',
            is_wireless_device: 'false',
            is_wml_preferred: 'false',
            marketing_name: 'iPhone',
            mobile_browser: 'Safari',
            model_name: 'iPhone',
            pointing_method: 'touchscreen',
            preferred_markup: 'html_wi_w3_xhtmlbasic',
            progressive_download: 'true',
            release_date: '2011',
            resolution_height: '1136',
            resolution_width: '640',
            ux_full_desktop: 'false',
            xhtml_support_level: '1',
        };
        // TODO check that these are accurate
        // this is only used in dev mode, we cannot end in execution plan if we are in dev mode
        this.location = location !== null && location !== void 0 ? location : {
            asn: 'Telia Eesti',
            city: 'Tallinn',
            continent: 'Europe',
            dms_code: '',
            country: 'EE',
            latitude: '59.433',
            longitude: '24.7323',
            postal_code: '11911',
            region_code: 'EU',
        };
        const modRewrite = new ModRewrite_1.default(this);
        const modCache = new ModCache_1.default(this);
        const modAccess = new ModAccess_1.default(this);
        const modSetEnv = new ModSetEnv_1.default(this);
        const modProxyCore = new ModProxyCore_1.default(this);
        const modProxyFeatures = new ModProxyFeatures_1.default(this);
        const modRedirect = new ModRedirect_1.default(this);
        const modEdgeFunctions = new ModEdgeFunctions_1.default(this);
        const modTranscode = new ModTranscode_1.default(this);
        const modStream = new ModStream_1.default(this);
        this.revalidatePlan = [
            {
                phase: Phase_1.default.SendRequestContent,
                modules: [modEdgeFunctions, modProxyCore, modSetEnv],
            },
            {
                phase: Phase_1.default.HandleResponseDone,
                modules: [modRedirect, modSetEnv, modStream, modCache],
            },
        ];
        this.simulatorPlan = [
            {
                phase: Phase_1.default.UriRaw,
                modules: [modRewrite],
            },
            {
                phase: Phase_1.default.UriClean,
                modules: [modAccess, modRedirect, modSetEnv, modCache, modProxyFeatures, modStream],
            },
            {
                phase: Phase_1.default.HandleDocRoot,
                modules: [modCache, modTranscode],
            },
            ...this.revalidatePlan,
        ];
        this.writeHeadPlan = [
            {
                phase: Phase_1.default.HandleResponseHeader,
                modules: [modSetEnv, modCache, modTranscode],
            },
        ];
        this.streamPlan = [
            {
                phase: Phase_1.default.StreamResponse,
                modules: [modTranscode, modStream],
            },
        ];
        this.appPlan = [
            {
                phase: Phase_1.default.StreamResponse,
                modules: [modTranscode],
            },
        ];
    }
    /**
     * Executes all phases of the request lifecycle, applying features based on the configured rules.
     */
    async executeSimulator() {
        this.executingSimulator = true;
        // we setup streaming - this can be disabled through response.DisableStreaming in mods as needed
        this.response.setOnStream(async () => await this.executeStreamResponse());
        await (0, executePlan_1.default)(this.simulatorPlan);
        /**
         * We try to stream for cases, where the response wasnt streamed already.
         *
         * We need to do it separately, as we use early returns to stop simulator,
         * which would cause response not to be streamed. For example with set_done.
         *
         * If we wish to avoid this, we should replace EarlyReturn errors with
         * flag, which every mod can decide to act upon or not.
         */
        await (0, executePlan_1.default)(this.streamPlan);
        // we revalidate, but dont block the downstream processing / sending response back - but still save the promise for simpler testing
        this.revalidation = new Promise(resolve => this.executeRevalidate().then(resolve));
    }
    /**
     * Processes the request based on EDGIO_SERVERLESS_HINT_HEADER, if present.
     *
     * Multiple hints can be provided, separated by comma - where generally last one will be executed.
     * The exception is redirect, which takes precedence over anything else, as non-compute redirect
     * doesn't hit the compute at all, and only returns location in header back downstream.
     *
     * Multiple hints provide us the flexibility to use compute when the rules arent enough,
     * WITHOUT changing the functionality.
     *
     * Example:
     *  curl -H "x-edg-serverless-hint:compute:0" -v http://127.0.0.1:3000/compute
     *
     * @returns true if a hints were handled, otherwise false
     */
    async executeServerless() {
        const hintHeader = this.request.getHeader(constants_1.EDGIO_SERVERLESS_HINT_HEADER);
        if (!hintHeader) {
            log_1.default.trace('No serverless hints found.');
            return false;
        }
        // we get the serverless and INVERT THE ORDER, as generally the LAST ONE should be executed
        const hintsWithValue = hintHeader.split(',').reverse();
        // We search for redirect hint - when redirect is defined through edge, it will NEVER hit compute,
        // therefore we simulate that behaviour, and redirect takes precedence before anything else, and early exits.
        const redirectHint = hintsWithValue.find(value => value.startsWith(constants_1.EDGIO_SERVERLESS_HINTS.redirect));
        if (redirectHint) {
            log_1.default.trace('Serverless hint', redirectHint);
            await this.handleHint(redirectHint);
        }
        else {
            // If redirect isnt found, we just execute the last hint, as they overwrite. Note - Hints are in reverse order here.
            const hintToRun = hintsWithValue[0];
            log_1.default.trace('Serverless hint', hintToRun);
            await this.handleHint(hintToRun);
        }
        this.response.clear();
        // We expect user to update response's body - we dont allow him to stream (historically) directly from compute.
        // For streaming from compute, other means should be implemented - eg. something like ComputeStream.
        this.response.body && this.response.write(this.response.body);
        this.response.end();
        // If we arent in simulator, we need to stream the response.
        if (!this.executingSimulator) {
            // We run the response through custom plan, which reencodes the response as needed, streams it.
            // This is not a plan that matches sailfish - we just use it to reuse mods and existing plan executor.
            await (0, executePlan_1.default)(this.streamPlan);
        }
        return true;
    }
    /**
     * Processes the request based on provided hint.
     * @returns true if a hint was handled, otherwise false
     */
    async handleHint(hintWithValue) {
        const hint = hintWithValue.split(':').shift() || '';
        const value = hintWithValue.split(':').pop() || '';
        if (hint === constants_1.EDGIO_SERVERLESS_HINTS.app) {
            // we enable streaming, as we expect the app to stream the response
            this.response.setIsStreamable(true);
            //  Will get here when behind the edge to skip directly to fetching the response from the internal app server
            //  started by the connector.
            await this.executeApp();
            return true;
        }
        // If value exists, we execute serverless function
        if (value !== '') {
            //  Will get here when behind the edge to skip directly to running the callback passed to RouteHelper#compute
            await this.executeCompute(Number(value));
            return true;
        }
        log_1.default.trace(`Serverless hint with name '${hint}' was not found.`);
        return false;
    }
    async executeApp() {
        log_1.default.debug(`skipping to app`);
        this.response.setOnStream(async () => await this.executeStreamResponse());
        const appOrigin = this.propertyContext.getOrigin(origins_1.SERVERLESS_ORIGIN_NAME);
        await new Origin_1.default(appOrigin).fetch(this.request, this.response);
    }
    async executeCompute(functionIndex) {
        const fn = this.functions[functionIndex];
        if (!fn) {
            throw new Error(`Serverless function with index ${functionIndex} not found.`);
        }
        log_1.default.debug(`[RequestContext] skipping to compute, function #${functionIndex}`);
        await fn(this.request, this.response, this.propertyContext);
    }
    /**
     * Revalidates a cached response, fetching it from the origin and adding it to the cache if possible.
     */
    async executeRevalidate() {
        if (this.revalidate) {
            // we create new, fake response to avoid:
            //    - rewriting during downstream processing (esp. in dev environment, as the response is sent directly back)
            //    - having unwanted data from previous response (response headers are not removed in Backend.fetch)
            // is used only used as a data holder / helper method provider for saving into cache
            this.revalidateResponse = new LambdaResponse_1.default();
            this.useCacheFile = false;
            this.bypassCache = false;
            await (0, executePlan_1.default)(this.revalidatePlan);
            log_1.default.debug(`Revalidated ${this.originalPath}.`);
        }
    }
    /**
     * Function responsible for writing / streaming content back to the user, running relevant mods if needed.
     * We do not care about ending the stream here - that is done after the whole chain processes, in RequestHandler.
     *
     * If called after response has been streamed, does nothing.
     */
    async executeStreamResponse() {
        const response = this.getResponse();
        if (!response.isHeadersStreamed) {
            // we process mods only if this function is called as part of simulator processing
            if (this.executingSimulator) {
                // We need to update the headers through ModSetEnv and ModCache as is done in sailfish.
                await (0, executePlan_1.default)(this.writeHeadPlan);
            }
            else {
                // we know we're just streaming app content here - we need to setup encoding pipes - executing simple single mod plan
                await (0, executePlan_1.default)(this.appPlan);
            }
        }
        await response.stream();
    }
    /**
     * Calls the specified callback for each rule that matches the current state.
     * @param callback
     */
    forEachMatchingRule(callback) {
        this.rules.forEach((rule, i) => this.callIfMatched(rule, callback, i));
    }
    /**
     * Calls the specified callback for last matching rule.
     * @param callback return true to confirm the match
     */
    forLastMatchingRule(callback) {
        let isBreak = false;
        for (let i = this.rules.length - 1; i >= 0; i--) {
            const rule = this.rules[i];
            this.callIfMatched(rule, features => {
                if (callback(features)) {
                    isBreak = true;
                }
            }, i);
            if (isBreak) {
                break;
            }
        }
    }
    /**
     * Applies the features configured in the rule if the rule matches the request.
     * @param rule The rule to apply
     * @param callback
     */
    callIfMatched(rule, callback, index) {
        let matches = rule;
        if (matches.if) {
            const conditional = matches.if[0];
            // if
            if (this.isTrue(conditional)) {
                // then
                this.callIfMatched(matches.if[1], callback, index);
            }
            else if (matches.if[2]) {
                // else
                this.callIfMatched(matches.if[2], callback, index);
            }
        }
        else {
            callback(rule, index);
        }
    }
    /**
     * Tests if a conditional (if) evaluates to true.
     * @param conditional
     * @returns
     */
    isTrue(conditional) {
        var _a, _b, _c, _d;
        const operators = Object.keys(conditional);
        if (operators.length !== 1) {
            throw new Error(`Conditional statements must contain a single operator. The following operators were found: ${operators.join(', ')}`);
        }
        else if (conditional[exports.OR]) {
            if (conditional[exports.OR].every((c) => !this.isTrue(c))) {
                return false;
            }
        }
        else if (conditional[exports.AND]) {
            if (conditional[exports.AND].some((c) => !this.isTrue(c))) {
                return false;
            }
        }
        else if (conditional[exports.EQUALS_EXPRESS]) {
            const [left, right] = conditional[exports.EQUALS_EXPRESS].map((v) => this.eval(v));
            if (!(0, toPathRegexp_1.default)(right).test((_a = left === null || left === void 0 ? void 0 : left.toString()) !== null && _a !== void 0 ? _a : '')) {
                return false;
            }
        }
        else if (conditional[exports.EQUALS]) {
            const [left, right] = conditional[exports.EQUALS].map((v) => this.eval(v));
            if (left != right) {
                return false;
            }
        }
        else if (conditional[exports.NOT_EQUALS_EXPRESS]) {
            const [left, right] = (conditional[exports.NOT_EQUALS_EXPRESS].map((v) => this.eval(v)));
            if ((0, toPathRegexp_1.default)(right).test((_b = left === null || left === void 0 ? void 0 : left.toString()) !== null && _b !== void 0 ? _b : '')) {
                return false;
            }
        }
        else if (conditional[exports.NOT_EQUALS]) {
            const [left, right] = conditional[exports.NOT_EQUALS].map((v) => this.eval(v));
            if (left === right) {
                return false;
            }
        }
        else if (conditional[exports.LESS_THAN]) {
            const [left, right] = conditional[exports.LESS_THAN].map((v) => this.eval(v));
            if (!(Number(left) < Number(right))) {
                return false;
            }
        }
        else if (conditional[exports.LESS_THAN_OR_EQUALS]) {
            const [left, right] = (conditional[exports.LESS_THAN_OR_EQUALS].map((v) => this.eval(v)));
            if (!(Number(left) <= Number(right))) {
                return false;
            }
        }
        else if (conditional[exports.GREATER_THAN]) {
            const [left, right] = conditional[exports.GREATER_THAN].map((v) => this.eval(v));
            if (!(Number(left) > Number(right))) {
                return false;
            }
        }
        else if (conditional[exports.GREATER_THAN_OR_EQUALS]) {
            const [left, right] = (conditional[exports.GREATER_THAN_OR_EQUALS].map((v) => this.eval(v)));
            if (!(Number(left) >= Number(right))) {
                return false;
            }
        }
        else if (conditional[exports.MATCHES]) {
            const [left, right] = conditional[exports.MATCHES].map((v) => this.eval(v));
            if (!(0, toRegExp_1.default)(right).test((_c = left === null || left === void 0 ? void 0 : left.toString()) !== null && _c !== void 0 ? _c : '')) {
                return false;
            }
        }
        else if (conditional[exports.NOT_MATCHES]) {
            const [left, right] = conditional[exports.NOT_MATCHES].map((v) => this.eval(v));
            if ((0, toRegExp_1.default)(right).test((_d = left === null || left === void 0 ? void 0 : left.toString()) !== null && _d !== void 0 ? _d : '')) {
                return false;
            }
        }
        else if (conditional[exports.IN]) {
            // Features for IN operator should contain at first place left side
            // of the expression and the second place is the right side which is
            // an array of string values we want to match
            const left = this.eval(conditional[exports.IN][0]);
            // both string and number primitives are possible
            // BUT is limited to only one by types of matchers
            const right = conditional[exports.IN][1];
            if (!right.some((v) => v === left))
                return false;
        }
        else if (conditional[exports.NOT_IN]) {
            const left = this.eval(conditional[exports.IN][0]);
            const right = conditional[exports.IN][1];
            // this is the same as for IN operator, we just reverse condition
            if (right.some((v) => v === left))
                return false;
        }
        else {
            throw new Error(`Unsupported operator "${Object.keys(conditional)[0]}".`);
        }
        return true;
    }
    /**
     * Evaluates an operands, which may be a constant or RulesVariable instance.
     * @param operand
     * @returns
     */
    eval(operand) {
        if (operand == null) {
            return operand;
        }
        else if (typeof operand === 'string') {
            return operand;
        }
        else if (typeof operand === 'boolean') {
            return operand;
        }
        else if (typeof operand === 'number') {
            return operand;
        }
        else {
            return this.evalVariable(operand);
        }
    }
    /**
     * Evaluates a RulesVariable instance based on the current request and response.
     * @param variable
     * @returns
     */
    evalVariable(variable) {
        if (variable.request) {
            switch (variable.request) {
                case 'client_ip':
                    return this.request.socket.remoteAddress;
                case 'pop_code':
                    return process.env.POP_CODE;
                case 'method':
                    return this.request.method.toUpperCase();
                case 'origin_path':
                    return this.request.path;
                case 'path':
                    return this.originalPath;
                case 'origin_query_string':
                    return this.request.url.split('?')[1];
                case 'query':
                    return this.originalQueryString;
                case 'scheme':
                    return this.request.secure ? 'https' : 'http';
                case 'referring_domain': {
                    const referrer = this.request.getHeader('referrer');
                    if (referrer) {
                        const splitReferrer = referrer.split('/');
                        if (splitReferrer.length > 2) {
                            // we get just the domain, as defined in edge docs
                            // https://docs.edgecast.com/cdn/Content/HRE/M/Referring-Domain-Literal.htm
                            return referrer.split('/')[2];
                        }
                    }
                    return '';
                }
                default: {
                    throw new Error(`Unsupported request property "${variable.request}".`);
                }
            }
        }
        else if (variable['request.header']) {
            const header = variable['request.header'];
            return (0, first_1.default)(this.request.getHeader(header));
        }
        else if (variable['request.cookie']) {
            const cookieName = variable['request.cookie'];
            return this.cookies[cookieName];
        }
        else if (variable['request.origin_query']) {
            const param = variable['request.origin_query'];
            return this.request.query && this.request.query[param];
        }
        else if (variable.variable) {
            return this.variables[variable.variable];
        }
        else if (variable['request.path']) {
            const param = variable['request.path'];
            switch (param) {
                case 'filename':
                    return path_1.default.basename(this.request.path);
                case 'extension':
                    return path_1.default.extname(this.request.path);
                case 'directory':
                    return path_1.default.dirname(this.request.path);
            }
        }
        else if (variable.location) {
            return this.location[variable.location];
        }
        else if (variable.random) {
            return Math.floor(Math.random() * (variable['random'] + 1));
        }
        else if (variable.device) {
            return this.device[variable.device];
        }
        else if (variable.response === 'status_code') {
            return this.originResponseStatus;
        }
        else {
            throw new Error(`Unsupported variable "${Object.keys(variable)[0]}".`);
        }
    }
    getRequest() {
        return this.request;
    }
    getResponse() {
        var _a;
        // If revalidateResponse exists, we're in the process of revalidation.
        return (_a = this.revalidateResponse) !== null && _a !== void 0 ? _a : this.response;
    }
    /**
     * Adds/appends a value to a request header
     * @param feature
     * @param forceAppend
     */
    setRequestHeader(feature, forceAppend) {
        return this.setHeader(this.getRequest(), feature, forceAppend);
    }
    /**
     * Adds/appends a value to a response header
     * @param feature
     * @package forceAppend
     */
    setResponseHeader(feature, forceAppend) {
        return this.setHeader(this.getResponse(), feature, forceAppend);
    }
    setHeader(target, feature, allowMultiple) {
        var _a;
        const targetFeature = (0, interpolate_1.interpolateObject)(feature, this);
        for (let [name, value] of Object.entries(targetFeature)) {
            const evaluatedValue = (_a = this.eval(value)) === null || _a === void 0 ? void 0 : _a.toString();
            if (evaluatedValue) {
                let outputHeader = evaluatedValue;
                if (name.startsWith('+')) {
                    name = name.substring(1);
                    const curVal = target.getHeader(name);
                    // right now we append to all header values - cant verify this is correct against sailfish at the moment
                    if (curVal) {
                        outputHeader = Array.isArray(curVal)
                            ? curVal.map(value => value + ',' + evaluatedValue)
                            : curVal + ',' + evaluatedValue;
                    }
                }
                else {
                    const curVal = target.getHeader(name);
                    // array outputs headers in separate entries having the same key
                    if (curVal && allowMultiple) {
                        outputHeader = Array.isArray(curVal)
                            ? [...curVal, evaluatedValue]
                            : [curVal, evaluatedValue];
                    }
                }
                target.setHeader(name, outputHeader);
            }
            else {
                target.removeHeader(name);
            }
        }
    }
    /**
     * Summarizes the context of received request.
     */
    summarize() {
        return `${this.request.method.toUpperCase()} ${this.originalPath}${this.originalQueryString || ''}`;
    }
}
exports.default = RequestContext;
