"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/runtime/edge-functions/bundled-object-inspect.js
var require_bundled_object_inspect = __commonJS({
  "src/runtime/edge-functions/bundled-object-inspect.js"(exports2, module2) {
    "use strict";
    var Et = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
    var et = Et(() => {
    });
    var U = typeof Map == "function" && Map.prototype;
    var N = Object.getOwnPropertyDescriptor && U ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var I = U && N && typeof N.get == "function" ? N.get : null;
    var rt = U && Map.prototype.forEach;
    var K = typeof Set == "function" && Set.prototype;
    var C = Object.getOwnPropertyDescriptor && K ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var L = K && C && typeof C.get == "function" ? C.get : null;
    var nt = K && Set.prototype.forEach;
    var $t = typeof WeakMap == "function" && WeakMap.prototype;
    var w = $t ? WeakMap.prototype.has : null;
    var Mt = typeof WeakSet == "function" && WeakSet.prototype;
    var E = Mt ? WeakSet.prototype.has : null;
    var Wt = typeof WeakRef == "function" && WeakRef.prototype;
    var at = Wt ? WeakRef.prototype.deref : null;
    var It = Boolean.prototype.valueOf;
    var Lt = Object.prototype.toString;
    var _t = Function.prototype.toString;
    var Rt = String.prototype.match;
    var Q = String.prototype.slice;
    var s = String.prototype.replace;
    var kt = String.prototype.toUpperCase;
    var it = String.prototype.toLowerCase;
    var gt = RegExp.prototype.test;
    var ot = Array.prototype.concat;
    var u = Array.prototype.join;
    var qt = Array.prototype.slice;
    var ft = Math.floor;
    var z = typeof BigInt == "function" ? BigInt.prototype.valueOf : null;
    var B = Object.getOwnPropertySymbols;
    var F = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null;
    var m = typeof Symbol == "function" && typeof Symbol.iterator == "object";
    var o = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === m ? "object" : "symbol") ? Symbol.toStringTag : null;
    var vt = Object.prototype.propertyIsEnumerable;
    var lt = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
      return t.__proto__;
    } : null);
    function ut(t, e) {
      if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || gt.call(/e/, e))
        return e;
      var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof t == "number") {
        var a = t < 0 ? -ft(-t) : ft(t);
        if (a !== t) {
          var i = String(a), r = Q.call(e, i.length + 1);
          return s.call(i, n, "$&_") + "." + s.call(s.call(r, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return s.call(e, n, "$&_");
    }
    var H = et();
    var ct = H.custom;
    var pt = ht(ct) ? ct : null;
    module2.exports = function t(e, n, a, i) {
      var r = n || {};
      if (y(r, "quoteStyle") && r.quoteStyle !== "single" && r.quoteStyle !== "double")
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      if (y(r, "maxStringLength") && (typeof r.maxStringLength == "number" ? r.maxStringLength < 0 && r.maxStringLength !== 1 / 0 : r.maxStringLength !== null))
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      var c = y(r, "customInspect") ? r.customInspect : true;
      if (typeof c != "boolean" && c !== "symbol")
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      if (y(r, "indent") && r.indent !== null && r.indent !== "	" && !(parseInt(r.indent, 10) === r.indent && r.indent > 0))
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      if (y(r, "numericSeparator") && typeof r.numericSeparator != "boolean")
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      var v = r.numericSeparator;
      if (typeof e > "u")
        return "undefined";
      if (e === null)
        return "null";
      if (typeof e == "boolean")
        return e ? "true" : "false";
      if (typeof e == "string")
        return dt(e, r);
      if (typeof e == "number") {
        if (e === 0)
          return 1 / 0 / e > 0 ? "0" : "-0";
        var f = String(e);
        return v ? ut(e, f) : f;
      }
      if (typeof e == "bigint") {
        var p = String(e) + "n";
        return v ? ut(e, p) : p;
      }
      var _ = typeof r.depth > "u" ? 5 : r.depth;
      if (typeof a > "u" && (a = 0), a >= _ && _ > 0 && typeof e == "object")
        return V(e) ? "[Array]" : "[Object]";
      var S = Yt(r, a);
      if (typeof i > "u")
        i = [];
      else if (mt(i, e) >= 0)
        return "[Circular]";
      function l(h, M, wt) {
        if (M && (i = qt.call(i), i.push(M)), wt) {
          var tt = { depth: r.depth };
          return y(r, "quoteStyle") && (tt.quoteStyle = r.quoteStyle), t(h, tt, a + 1, i);
        }
        return t(h, r, a + 1, i);
      }
      if (typeof e == "function" && !yt(e)) {
        var G = Ft(e), X = W(e, l);
        return "[Function" + (G ? ": " + G : " (anonymous)") + "]" + (X.length > 0 ? " { " + u.call(X, ", ") + " }" : "");
      }
      if (ht(e)) {
        var Y = m ? s.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : F.call(e);
        return typeof e == "object" && !m ? O(Y) : Y;
      }
      if (Qt(e)) {
        for (var d = "<" + it.call(String(e.nodeName)), R = e.attributes || [], $ = 0; $ < R.length; $++)
          d += " " + R[$].name + "=" + St(At(R[$].value), "double", r);
        return d += ">", e.childNodes && e.childNodes.length && (d += "..."), d += "</" + it.call(String(e.nodeName)) + ">", d;
      }
      if (V(e)) {
        if (e.length === 0)
          return "[]";
        var k = W(e, l);
        return S && !Xt(k) ? "[" + J(k, S) + "]" : "[ " + u.call(k, ", ") + " ]";
      }
      if (Dt(e)) {
        var q = W(e, l);
        return !("cause" in Error.prototype) && "cause" in e && !vt.call(e, "cause") ? "{ [" + String(e) + "] " + u.call(ot.call("[cause]: " + l(e.cause), q), ", ") + " }" : q.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + u.call(q, ", ") + " }";
      }
      if (typeof e == "object" && c) {
        if (pt && typeof e[pt] == "function" && H)
          return H(e, { depth: _ - a });
        if (c !== "symbol" && typeof e.inspect == "function")
          return e.inspect();
      }
      if (Ht(e)) {
        var Z = [];
        return rt && rt.call(e, function(h, M) {
          Z.push(l(M, e, true) + " => " + l(h, e));
        }), st("Map", I.call(e), Z, S);
      }
      if (Ut(e)) {
        var x = [];
        return nt && nt.call(e, function(h) {
          x.push(l(h, e));
        }), st("Set", L.call(e), x, S);
      }
      if (Vt(e))
        return P("WeakMap");
      if (Kt(e))
        return P("WeakSet");
      if (Jt(e))
        return P("WeakRef");
      if (Ct(e))
        return O(l(Number(e)));
      if (Pt(e))
        return O(l(z.call(e)));
      if (Bt(e))
        return O(It.call(e));
      if (Nt(e))
        return O(l(String(e)));
      if (!Tt(e) && !yt(e)) {
        var A = W(e, l), b = lt ? lt(e) === Object.prototype : e instanceof Object || e.constructor === Object, T = e instanceof Object ? "" : "null prototype", j = !b && o && Object(e) === e && o in e ? Q.call(g(e), 8, -1) : T ? "Object" : "", Ot = b || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", D = Ot + (j || T ? "[" + u.call(ot.call([], j || [], T || []), ": ") + "] " : "");
        return A.length === 0 ? D + "{}" : S ? D + "{" + J(A, S) + "}" : D + "{ " + u.call(A, ", ") + " }";
      }
      return String(e);
    };
    function St(t, e, n) {
      var a = (n.quoteStyle || e) === "double" ? '"' : "'";
      return a + t + a;
    }
    function At(t) {
      return s.call(String(t), /"/g, "&quot;");
    }
    function V(t) {
      return g(t) === "[object Array]" && (!o || !(typeof t == "object" && o in t));
    }
    function Tt(t) {
      return g(t) === "[object Date]" && (!o || !(typeof t == "object" && o in t));
    }
    function yt(t) {
      return g(t) === "[object RegExp]" && (!o || !(typeof t == "object" && o in t));
    }
    function Dt(t) {
      return g(t) === "[object Error]" && (!o || !(typeof t == "object" && o in t));
    }
    function Nt(t) {
      return g(t) === "[object String]" && (!o || !(typeof t == "object" && o in t));
    }
    function Ct(t) {
      return g(t) === "[object Number]" && (!o || !(typeof t == "object" && o in t));
    }
    function Bt(t) {
      return g(t) === "[object Boolean]" && (!o || !(typeof t == "object" && o in t));
    }
    function ht(t) {
      if (m)
        return t && typeof t == "object" && t instanceof Symbol;
      if (typeof t == "symbol")
        return true;
      if (!t || typeof t != "object" || !F)
        return false;
      try {
        return F.call(t), true;
      } catch {
      }
      return false;
    }
    function Pt(t) {
      if (!t || typeof t != "object" || !z)
        return false;
      try {
        return z.call(t), true;
      } catch {
      }
      return false;
    }
    var zt = Object.prototype.hasOwnProperty || function(t) {
      return t in this;
    };
    function y(t, e) {
      return zt.call(t, e);
    }
    function g(t) {
      return Lt.call(t);
    }
    function Ft(t) {
      if (t.name)
        return t.name;
      var e = Rt.call(_t.call(t), /^function\s*([\w$]+)/);
      return e ? e[1] : null;
    }
    function mt(t, e) {
      if (t.indexOf)
        return t.indexOf(e);
      for (var n = 0, a = t.length; n < a; n++)
        if (t[n] === e)
          return n;
      return -1;
    }
    function Ht(t) {
      if (!I || !t || typeof t != "object")
        return false;
      try {
        I.call(t);
        try {
          L.call(t);
        } catch {
          return true;
        }
        return t instanceof Map;
      } catch {
      }
      return false;
    }
    function Vt(t) {
      if (!w || !t || typeof t != "object")
        return false;
      try {
        w.call(t, w);
        try {
          E.call(t, E);
        } catch {
          return true;
        }
        return t instanceof WeakMap;
      } catch {
      }
      return false;
    }
    function Jt(t) {
      if (!at || !t || typeof t != "object")
        return false;
      try {
        return at.call(t), true;
      } catch {
      }
      return false;
    }
    function Ut(t) {
      if (!L || !t || typeof t != "object")
        return false;
      try {
        L.call(t);
        try {
          I.call(t);
        } catch {
          return true;
        }
        return t instanceof Set;
      } catch {
      }
      return false;
    }
    function Kt(t) {
      if (!E || !t || typeof t != "object")
        return false;
      try {
        E.call(t, E);
        try {
          w.call(t, w);
        } catch {
          return true;
        }
        return t instanceof WeakSet;
      } catch {
      }
      return false;
    }
    function Qt(t) {
      return !t || typeof t != "object" ? false : typeof HTMLElement < "u" && t instanceof HTMLElement ? true : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
    }
    function dt(t, e) {
      if (t.length > e.maxStringLength) {
        var n = t.length - e.maxStringLength, a = "... " + n + " more character" + (n > 1 ? "s" : "");
        return dt(Q.call(t, 0, e.maxStringLength), e) + a;
      }
      var i = s.call(s.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Gt);
      return St(i, "single", e);
    }
    function Gt(t) {
      var e = t.charCodeAt(0), n = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[e];
      return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + kt.call(e.toString(16));
    }
    function O(t) {
      return "Object(" + t + ")";
    }
    function P(t) {
      return t + " { ? }";
    }
    function st(t, e, n, a) {
      var i = a ? J(n, a) : u.call(n, ", ");
      return t + " (" + e + ") {" + i + "}";
    }
    function Xt(t) {
      for (var e = 0; e < t.length; e++)
        if (mt(t[e], `
`) >= 0)
          return false;
      return true;
    }
    function Yt(t, e) {
      var n;
      if (t.indent === "	")
        n = "	";
      else if (typeof t.indent == "number" && t.indent > 0)
        n = u.call(Array(t.indent + 1), " ");
      else
        return null;
      return { base: n, prev: u.call(Array(e + 1), n) };
    }
    function J(t, e) {
      if (t.length === 0)
        return "";
      var n = `
` + e.prev + e.base;
      return n + u.call(t, "," + n) + `
` + e.prev;
    }
    function W(t, e) {
      var n = V(t), a = [];
      if (n) {
        a.length = t.length;
        for (var i = 0; i < t.length; i++)
          a[i] = y(t, i) ? e(t[i], t) : "";
      }
      var r = typeof B == "function" ? B(t) : [], c;
      if (m) {
        c = {};
        for (var v = 0; v < r.length; v++)
          c["$" + r[v]] = r[v];
      }
      for (var f in t)
        !y(t, f) || n && String(Number(f)) === f && f < t.length || m && c["$" + f] instanceof Symbol || (gt.call(/[^\w$]/, f) ? a.push(e(f, t) + ": " + e(t[f], t)) : a.push(f + ": " + e(t[f], t)));
      if (typeof B == "function")
        for (var p = 0; p < r.length; p++)
          vt.call(t, r[p]) && a.push("[" + e(r[p]) + "]: " + e(t[r[p]], t));
      return a;
    }
  }
});

// node_modules/fastestsmallesttextencoderdecoder-encodeinto/NodeJS/EncoderAndDecoderNodeJS.min.js
var require_EncoderAndDecoderNodeJS_min = __commonJS({
  "node_modules/fastestsmallesttextencoderdecoder-encodeinto/NodeJS/EncoderAndDecoderNodeJS.min.js"(exports2, module2) {
    "use strict";
    (function(q) {
      var v = String.fromCharCode, y = {}.toString, w = q.SharedArrayBuffer, N = w ? y.call(w) : "", u = q.Uint8Array, O = u ? y.call(ArrayBuffer.prototype) : "", n = q.Buffer, D = /[\x80-\uD7ff\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g, c = new Uint16Array(32);
      try {
        !n && q.require && (n = q.require("Buffer"));
        var E = n.prototype;
        var P = n ? y.call(E) : "";
      } catch (a) {
      }
      var F = !!u && !n, Q = !n || !!u && u.prototype.isPrototypeOf(E), x = q.TextEncoder, B = q.TextDecoder;
      if (F || n) {
        var A = function(a) {
          a.TextDecoder = B || G;
          a.TextEncoder = x || H;
          a !== q && (a.decode = B ? C(new B(), "decode") : I, a.encode = x ? C(z, "encode") : J, a.encodeInto = K);
          return a;
        }, C = function(a, b, e) {
          e = a[b];
          return function() {
            return e.apply(a, arguments);
          };
        }, M = function(a, b) {
          var e = void 0 === a ? "" : ("" + a).replace(D, L), d = e.length | 0, f = 0, k = 0, r = b.length | 0, g = a.length | 0;
          r < d && (d = r);
          a:
            for (; f < d; f = f + 1 | 0) {
              a = e.charCodeAt(f) | 0;
              switch (a >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                  k = k + 1 | 0;
                case 8:
                case 9:
                case 10:
                case 11:
                  break;
                case 12:
                case 13:
                  if ((f + 1 | 0) < r) {
                    k = k + 1 | 0;
                    break;
                  }
                case 14:
                  if ((f + 2 | 0) < r) {
                    k = k + 1 | 0;
                    break;
                  }
                case 15:
                  if ((f + 3 | 0) < r) {
                    k = k + 1 | 0;
                    break;
                  }
                default:
                  break a;
              }
              b[f] = a;
            }
          return { written: f, read: g < k ? g : k };
        }, J = function(a) {
          a = void 0 === a ? "" : ("" + a).replace(D, L);
          for (var b = a.length | 0, e = F ? new u(b) : n.allocUnsafe ? n.allocUnsafe(b) : new n(b), d = 0; d < b; d = d + 1 | 0)
            e[d] = a.charCodeAt(d) | 0;
          return e;
        }, H = function() {
        }, L = function(a) {
          var b = a.charCodeAt(0) | 0;
          if (55296 <= b && 56319 >= b)
            if (a = a.charCodeAt(1) | 0, 56320 <= a && 57343 >= a) {
              if (b = (b << 10) + a - 56613888 | 0, 65535 < b)
                return v(240 | b >> 18, 128 | b >> 12 & 63, 128 | b >> 6 & 63, 128 | b & 63);
            } else
              b = 65533;
          return 2047 >= b ? v(192 | b >> 6, 128 | b & 63) : v(224 | b >> 12, 128 | b >> 6 & 63, 128 | b & 63);
        }, I = function(a) {
          var b = a && a.buffer || a, e = y.call(b);
          if (e !== O && e !== P && e !== N && "[object ArrayBuffer]" !== e && void 0 !== a)
            throw TypeError("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
          a = Q ? new u(b) : b || [];
          e = b = "";
          for (var d = 0, f = a.length | 0, k = f - 32 | 0, r, g, h = 0, t = 0, m, l = 0, p = -1; d < f; ) {
            for (r = d <= k ? 32 : f - d | 0; l < r; d = d + 1 | 0, l = l + 1 | 0) {
              g = a[d] & 255;
              switch (g >> 4) {
                case 15:
                  m = a[d = d + 1 | 0] & 255;
                  if (2 !== m >> 6 || 247 < g) {
                    d = d - 1 | 0;
                    break;
                  }
                  h = (g & 7) << 6 | m & 63;
                  t = 5;
                  g = 256;
                case 14:
                  m = a[d = d + 1 | 0] & 255, h <<= 6, h |= (g & 15) << 6 | m & 63, t = 2 === m >> 6 ? t + 4 | 0 : 24, g = g + 256 & 768;
                case 13:
                case 12:
                  m = a[d = d + 1 | 0] & 255, h <<= 6, h |= (g & 31) << 6 | m & 63, t = t + 7 | 0, d < f && 2 === m >> 6 && h >> t && 1114112 > h ? (g = h, h = h - 65536 | 0, 0 <= h && (p = (h >> 10) + 55296 | 0, g = (h & 1023) + 56320 | 0, 31 > l ? (c[l] = p, l = l + 1 | 0, p = -1) : (m = p, p = g, g = m))) : (g >>= 8, d = d - g - 1 | 0, g = 65533), h = t = 0, r = d <= k ? 32 : f - d | 0;
                default:
                  c[l] = g;
                  continue;
                case 11:
                case 10:
                case 9:
                case 8:
              }
              c[l] = 65533;
            }
            e += v(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13], c[14], c[15], c[16], c[17], c[18], c[19], c[20], c[21], c[22], c[23], c[24], c[25], c[26], c[27], c[28], c[29], c[30], c[31]);
            32 > l && (e = e.slice(0, l - 32 | 0));
            if (d < f) {
              if (c[0] = p, l = ~p >>> 31, p = -1, e.length < b.length)
                continue;
            } else
              -1 !== p && (e += v(p));
            b += e;
            e = "";
          }
          return b;
        }, G = function() {
        };
        G.prototype.decode = I;
        w = H.prototype;
        w.encode = J;
        var K = w.encodeInto = M;
        if (x) {
          var z = new x();
          K = z.encodeInto ? C(z, "encode") : x.prototype.encodeInto = function(a, b) {
            var e = a.length | 0, d = b.length | 0;
            if (e < d >> 1) {
              var f = z.encode(a);
              if ((f.length | 0) < d)
                return b.set(f), { read: e, written: f.length | 0 };
            }
            return M(a, b);
          };
        }
        "object" === typeof exports2 && "undefined" !== typeof module2 ? A(module2.exports) : typeof define == typeof A && "function" === typeof define && define.amd ? define(function() {
          return A({});
        }) : A(q);
      }
    })("undefined" == typeof global ? "undefined" == typeof self ? exports2 || {} : self : global);
  }
});

// src/runtime/edge-functions/sdk.js
module.exports = function({ host, utility }, edgioRequestId, edgeFunctions) {
  const STDOUT_FD = 1;
  const STDERR_FD = 2;
  const ENV_VAR_NAMESPACE_EDGIO_CONFIG = "edgio-config";
  const ENV_VAR_NAMESPACE_EDGIO_ORIGINS = "edgio-origins";
  const ENV_VAR_NAMESPACE_EDGIO_USRVAR = "edgio-usrvar";
  const EdgioId = Symbol("edgio-id");
  const Done = Symbol("done");
  const Options = Symbol("options");
  const Headers = Symbol("headers");
  const BodyUsed = Symbol("body-used");
  const BodyDefined = Symbol("body-defined");
  const GetBody = Symbol("get-body");
  const Namespace = Symbol("namespace");
  const AppendFn = Symbol("append-fn");
  const CheckFn = Symbol("check-fn");
  const GetFn = Symbol("get-fn");
  const KeysFn = Symbol("keys-fn");
  const Redirected = Symbol("redirected");
  const RemoveFn = Symbol("remove-fn");
  const SetFn = Symbol("set-fn");
  const Url = Symbol("url");
  const ErrorCode = Symbol("error-code");
  const InternalErrorPrefix = "Internal Error: ";
  const inspect = require_bundled_object_inspect();
  let consoleGroupIndentDepth = 0;
  const CONSOLE_GROUP_INDENT_STEP = 2;
  const getConsoleIndent = () => " ".repeat(consoleGroupIndentDepth);
  function wrappedConsoleWrite(fdWrite, ...args) {
    fdWrite(getConsoleIndent());
    if (args.length > 0) {
      let firstArg = args[0];
      if (typeof firstArg === "string") {
        args.shift();
        firstArg = firstArg.replace(/%[oOdisf]/g, (match) => {
          if (args.length === 0) {
            return match;
          }
          const arg = args.shift();
          switch (match) {
            case "%o":
            case "%O":
              return inspect(arg);
            case "%d":
            case "%i":
              return parseInt(arg, 10).toString();
            case "%s":
              return arg.toString();
            case "%f":
              return parseFloat(arg).toString();
            default:
              return match;
          }
        });
        args.unshift(firstArg);
      }
    }
    for (let i = 0; i < args.length; i++) {
      if (i !== 0) {
        fdWrite(" ");
      }
      const arg = args[i];
      const type = typeof arg;
      switch (type) {
        case "string":
          fdWrite(arg);
          break;
        case "number":
        case "function":
          fdWrite(arg.toString());
          break;
        case "boolean":
          fdWrite(arg ? "true" : "false");
          break;
        case "undefined":
        case "null":
          fdWrite(type);
          break;
        default:
          if (arg === null) {
            fdWrite("null");
          } else {
            fdWrite(inspect(arg));
          }
          break;
      }
    }
    fdWrite("\n");
  }
  function consoleWrite(fd, ...args) {
    const fdWrite = utility.stream_write_all.bind(this, fd);
    try {
      return wrappedConsoleWrite(fdWrite, ...args);
    } catch (e) {
      fdWrite("Exception during console output: ");
      fdWrite(e.toString());
      fdWrite("\n");
    }
  }
  const consoleCounters = /* @__PURE__ */ new Map();
  globalThis.console = {
    assert: function(condition, ...args) {
      if (!condition) {
        consoleWrite(STDERR_FD, "Assertion failed:", ...args);
      }
    },
    clear: function() {
    },
    count: function(label) {
      consoleCounters.set(label, (consoleCounters.get(label) || 0) + 1);
      globalThis.console.log(`${label}: ${consoleCounters.get(label)}`);
    },
    countReset: function(label) {
      consoleCounters.set(label, 0);
    },
    debug: consoleWrite.bind(globalThis.console, STDOUT_FD),
    dir: function(...args) {
      return globalThis.console.log(...args);
    },
    dirxml: function(...args) {
      return globalThis.console.log(...args);
    },
    error: consoleWrite.bind(globalThis.console, STDERR_FD),
    group: function(...args) {
      if (args !== void 0) {
        globalThis.console.log(...args);
      }
      consoleGroupIndentDepth += CONSOLE_GROUP_INDENT_STEP;
    },
    groupCollapsed: function(...args) {
      return globalThis.console.group(...args);
    },
    groupEnd: function() {
      consoleGroupIndentDepth = Math.max(consoleGroupIndentDepth - CONSOLE_GROUP_INDENT_STEP, 0);
    },
    info: consoleWrite.bind(globalThis.console, STDOUT_FD),
    log: consoleWrite.bind(globalThis.console, STDOUT_FD),
    profile: function() {
    },
    table: function(data, columns) {
      return globalThis.console.warn("table not implemented", data, columns);
    },
    time: function() {
    },
    timeEnd: function(label) {
      return globalThis.console.warn("timeEnd not implemented", label);
    },
    timeLog: function(label) {
      return globalThis.console.warn("timeLog not implemented", label);
    },
    timeStamp: function() {
    },
    trace: consoleWrite.bind(globalThis.console, STDOUT_FD),
    warn: consoleWrite.bind(globalThis.console, STDERR_FD)
  };
  const _EdgioReadableStreamReader = class {
    constructor(id, getBodyFn) {
      if (this.constructor == _EdgioReadableStreamReader) {
        throw new Error(`${InternalErrorPrefix}EdgioReadableStreamReader Abstract class cannot be instantiated directly.`);
      }
      this[EdgioId] = id;
      this[GetBody] = getBodyFn;
      this[Done] = false;
    }
    async read() {
      const body = new Uint8Array(this[GetBody](this[EdgioId]));
      this[Done] = true;
      return { value: body };
    }
  };
  let EdgioReadableStreamReader = _EdgioReadableStreamReader;
  __publicField(EdgioReadableStreamReader, "BUFFER_SIZE", 1024);
  class EdgioReadableResponseStreamReader extends EdgioReadableStreamReader {
    constructor(responseId) {
      super(responseId, host.hostcall_resp_get_body);
    }
  }
  class EdgioReadableRequestStreamReader extends EdgioReadableStreamReader {
    constructor(requestId) {
      super(requestId, host.hostcall_req_get_body);
    }
  }
  class EdgioReadableResponseStream {
    constructor(responseId) {
      this[EdgioId] = responseId;
    }
    getReader() {
      return new EdgioReadableResponseStreamReader(this[EdgioId]);
    }
  }
  class EdgioReadableRequestStream {
    constructor(requestId) {
      this[EdgioId] = requestId;
    }
    getReader() {
      return new EdgioReadableRequestStreamReader(this[EdgioId]);
    }
  }
  class EdgioHeaders {
    constructor(id, headers, { appendFn, checkFn, getFn, keysFn, removeFn, setFn }) {
      if (this.constructor == EdgioHeaders) {
        throw new Error(`${InternalErrorPrefix}Headers Abstract class cannot be instantiated directly.`);
      }
      this[EdgioId] = id;
      this[AppendFn] = appendFn;
      this[CheckFn] = checkFn;
      this[GetFn] = getFn;
      this[KeysFn] = keysFn;
      this[RemoveFn] = removeFn;
      this[SetFn] = setFn;
      if (Array.isArray(headers)) {
        headers.forEach((h) => {
          if (!Array.isArray(h)) {
            throw new Error(`When passing an array of headers, each array element must be an array of length = 2. '${h}' is type '${typeof h}' not type array.`);
          }
          if (h.length !== 2) {
            throw new Error(`When passing an array of headers, each array element must be an array of length = 2. '${h}' is array of length ${h.length}.`);
          }
          host.hostcall_debug(`.append(${h})`);
          this.append(h[0], h[1]);
        });
      } else if (headers && Function.prototype.toString.call(headers.constructor).match(/class.*/)) {
        throw new Error(`'headers' must be a dictionary or an array of array pairs. Found ${Function.prototype.toString.call(headers.constructor)}`);
      } else if (typeof headers === "object") {
        Object.keys(headers).forEach((name) => {
          this.append(name, headers[name]);
        });
      } else if (typeof headers !== "undefined") {
        throw new Error(`'headers' must be a dictionary or an array of array pairs. Found type ${typeof headers}.`);
      }
    }
    _validateName(name) {
      if (name === void 0) {
        throw new Error("The 'name' argument is required, but was not present.");
      }
      if (typeof name !== "string") {
        throw new Error(`The 'name' argument must be a 'string' type, not a '${typeof name}' type.`);
      }
      return name;
    }
    _validateValue(value) {
      if (value === void 0) {
        throw new Error("The 'value' argument is required, but was not present.");
      }
      if (typeof value !== "string" && !Array.isArray(value)) {
        throw new Error(`The 'value' argument must be a 'string' or 'array' type, not a '${typeof value}' type.`);
      }
      return value;
    }
    append(name, value) {
      this[AppendFn](this[EdgioId], this._validateName(name), this._validateValue(value));
    }
    delete(name) {
      this[RemoveFn](this[EdgioId], this._validateName(name));
    }
    entries() {
      const entries = [];
      for (const key of this.keys()) {
        entries.push([key, this.get(key)]);
      }
      return entries;
    }
    forEach(callback) {
      for (const key of this.keys()) {
        callback(this.get(key), key);
      }
    }
    get(name) {
      const headers = this[GetFn](this[EdgioId], this._validateName(name));
      if (Array.isArray(headers))
        return headers.join(", ");
      return typeof headers === "undefined" ? null : headers;
    }
    has(name) {
      return this[CheckFn](this[EdgioId], this._validateName(name));
    }
    keys() {
      return this[KeysFn](this[EdgioId]);
    }
    set(name, value) {
      this[SetFn](this[EdgioId], this._validateName(name), this._validateValue(value));
    }
    values() {
      const values = [];
      for (const key of this.keys()) {
        values.push(this.get(key));
      }
      return values;
    }
    toJSON() {
      const json = {};
      for (const key of this.keys()) {
        json[key] = this.get(key);
      }
      return json;
    }
  }
  class EdgioResponseHeaders extends EdgioHeaders {
    constructor(responseId, headers) {
      super(responseId, headers, {
        appendFn: host.hostcall_resp_append_header,
        checkFn: host.hostcall_resp_check_header,
        getFn: host.hostcall_resp_get_header_values,
        keysFn: utility.resp_get_header_names,
        removeFn: host.hostcall_resp_remove_header,
        setFn: host.hostcall_resp_set_header
      });
    }
  }
  class EdgioRequestHeaders extends EdgioHeaders {
    constructor(requestId, headers) {
      super(requestId, headers, {
        appendFn: host.hostcall_req_append_header,
        checkFn: host.hostcall_req_check_header,
        getFn: host.hostcall_req_get_header_values,
        keysFn: utility.req_get_header_names,
        removeFn: host.hostcall_req_remove_header,
        setFn: host.hostcall_req_set_header
      });
    }
  }
  globalThis.Request = class {
    constructor(input, options) {
      this[Options] = options || {};
      if (typeof options?.edgio?.id === "number") {
        this[EdgioId] = options?.edgio?.id;
        this[Headers] = new EdgioRequestHeaders(this[EdgioId]);
        host.hostcall_debug(`sdk.js:Request(${input}, ${JSON.stringify(options)}) id: ${this[EdgioId]}`);
        return;
      }
      if (typeof input !== "string") {
        throw new Error(`"string" type is accepted for the input parameter, not '${typeof input}'`);
      }
      const url = input;
      if (this[Options].method !== void 0 && typeof this[Options].method !== "string") {
        throw new Error(`options.method must be type 'undefined' or 'string', not '${typeof this[Options].method}'`);
      }
      const method = this[Options].method || "GET";
      this[EdgioId] = host.hostcall_req_create(method, url);
      this[Headers] = new EdgioRequestHeaders(this[EdgioId], this[Options]?.headers || {});
      const body = this[Options].body;
      delete this[Options].body;
      this[BodyUsed] = false;
      if (body) {
        if (method === "GET" || method === "HEAD") {
          throw new Error("Request with GET/HEAD method cannot have body.");
        }
        if (typeof body === "string") {
          host.hostcall_debug(`new Request(${this[EdgioId]}, string: ${body})`);
          host.hostcall_req_set_body_from_string(this[EdgioId], body);
        } else if (body instanceof ArrayBuffer) {
          host.hostcall_debug(`new Request(ArrayBuffer: len=${body.byteLength})`);
          host.hostcall_req_set_body_from_array_buffer(this[EdgioId], body);
        } else if (ArrayBuffer.isView(body)) {
          host.hostcall_debug(`new Request(TypedArray: len=${body.byteLength})`);
          host.hostcall_req_set_body_from_array_buffer(this[EdgioId], body.buffer);
        } else {
          host.hostcall_debug(`new Request(other: ${body.toString()})`);
          host.hostcall_req_set_body_from_string(this[EdgioId], body.toString());
        }
      }
      host.hostcall_debug(`sdk.js:Request(${input}, ${JSON.stringify(options)}) id: ${this[EdgioId]}`);
    }
    async arrayBuffer() {
      const stream = new EdgioReadableRequestStream(this[EdgioId]);
      const body = await stream.getReader().read();
      if (body.done) {
        return new ArrayBuffer(0);
      }
      this[BodyUsed] = true;
      return body.value.buffer;
    }
    blob() {
      throw new Error(`${InternalErrorPrefix}The 'blob' method is not supported by the Request class.`);
    }
    get body() {
      if (this.method === "GET" || this.method === "HEAD") {
        return null;
      }
      return new EdgioReadableRequestStream(this[EdgioId]);
    }
    get bodyUsed() {
      return this[BodyUsed];
    }
    get cache() {
      throw new Error(`${InternalErrorPrefix}The 'cache' property is not supported by the Request class.`);
    }
    get credentials() {
      throw new Error(`${InternalErrorPrefix}The 'credentials' property is not supported by the Request class.`);
    }
    clone() {
      throw new Error(`${InternalErrorPrefix}The 'clone' method is not supported by the Request class.`);
    }
    get destination() {
      throw new Error(`${InternalErrorPrefix}The 'destination' property is not supported by the Request class.`);
    }
    formData() {
      throw new Error(`${InternalErrorPrefix}The 'formData' method is not supported by the Request class.`);
    }
    get headers() {
      return this[Headers];
    }
    get integrity() {
      throw new Error(`${InternalErrorPrefix}The 'integrity' property is not supported by the Request class.`);
    }
    async json() {
      return JSON.parse(await this.text());
    }
    get method() {
      return host.hostcall_req_get_method(this[EdgioId]);
    }
    set method(method) {
      return host.hostcall_req_set_method(this[EdgioId], method);
    }
    get mode() {
      throw new Error(`${InternalErrorPrefix}The 'mode' property is not supported by the Request class.`);
    }
    get redirect() {
      throw new Error(`${InternalErrorPrefix}The 'redirect' property is not supported by the Request class.`);
    }
    get referrer() {
      throw new Error(`${InternalErrorPrefix}The 'referrer' property is not supported by the Request class.`);
    }
    get referrerPolicy() {
      throw new Error(`${InternalErrorPrefix}The 'referrerPolicy' property is not supported by the Request class.`);
    }
    get signal() {
      throw new Error(`${InternalErrorPrefix}The 'signal' property is not supported by the Request class.`);
    }
    async text() {
      const stream = new EdgioReadableRequestStream(this[EdgioId]);
      const body = await stream.getReader().read();
      if (body.done) {
        return "";
      }
      this[BodyUsed] = true;
      return new TextDecoder("utf-8").decode(body.value);
    }
    get url() {
      return host.hostcall_req_get_uri(this[EdgioId]);
    }
    set url(uri) {
      return host.hostcall_req_set_uri(this[EdgioId], uri);
    }
    get path() {
      return host.hostcall_req_get_path(this[EdgioId]);
    }
    get edgioId() {
      return this[EdgioId];
    }
    toJSON() {
      return {
        method: this.method,
        url: this.url,
        headers: this.headers
      };
    }
    cloneWithoutBody() {
      const clone_id = host.hostcall_req_clone_without_body(this[EdgioId]);
      const req = new Request(null, {
        edgio: {
          id: clone_id
        }
      });
      return req;
    }
  };
  globalThis.Response = class {
    constructor(body, options) {
      this[BodyUsed] = false;
      this[BodyDefined] = false;
      this[Redirected] = false;
      this[Url] = null;
      if (typeof options?.edgio?.id === "number") {
        this[EdgioId] = options?.edgio?.id;
        this[Headers] = new EdgioResponseHeaders(this[EdgioId]);
        host.hostcall_debug(`_edgioNew Response: ${this[EdgioId]}`);
        this[BodyDefined] = true;
        return;
      }
      this[Options] = options || {};
      this[Options].status = this[Options]?.status || 200;
      if (this[Options].status < 200 || this[Options].status > 599) {
        throw new Error(`The status provided ${this[Options].status} is outside of the standard range [200, 599].`);
      }
      this[EdgioId] = host.hostcall_resp_create(this[Options].status);
      this[Headers] = new EdgioResponseHeaders(this[EdgioId], this[Options]?.headers || {});
      host.hostcall_debug(`new Response: ${this[EdgioId]} ${JSON.stringify(this[Options]?.headers)}`);
      if (body) {
        if (typeof body === "string") {
          this[BodyDefined] = true;
          host.hostcall_debug(`new Response(string: ${body})`);
          host.hostcall_resp_set_body_from_string(this[EdgioId], body);
        } else if (body instanceof ArrayBuffer) {
          this[BodyDefined] = true;
          host.hostcall_debug(`new Response(ArrayBuffer: len=${body.byteLength})`);
          host.hostcall_resp_set_body_from_array_buffer(this[EdgioId], body);
        } else if (ArrayBuffer.isView(body)) {
          this[BodyDefined] = true;
          host.hostcall_debug(`new Response(TypedArray: len=${body.byteLength})`);
          host.hostcall_resp_set_body_from_array_buffer(this[EdgioId], body.buffer);
        } else {
          this[BodyDefined] = true;
          host.hostcall_debug(`new Response(other: ${body.toString()})`);
          host.hostcall_resp_set_body_from_string(this[EdgioId], body.toString());
        }
      }
    }
    async arrayBuffer() {
      if (this[BodyDefined]) {
        this[BodyUsed] = false;
        const body = await this.body.getReader().read();
        if (body.done) {
          return new ArrayBuffer(0);
        }
        return body.value.buffer;
      }
      return new ArrayBuffer(0);
    }
    blob() {
      throw new Error(`${InternalErrorPrefix}The 'blob' method is not supported by the Response class.`);
    }
    get body() {
      if (this[BodyDefined]) {
        return new EdgioReadableResponseStream(this[EdgioId]);
      }
      return null;
    }
    get bodyUsed() {
      return this[BodyUsed];
    }
    clone() {
      throw new Error(`${InternalErrorPrefix}The 'clone' method is not supported by the Response class.`);
    }
    formData() {
      throw new Error(`${InternalErrorPrefix}The 'formData' method is not supported by the Response class.`);
    }
    get headers() {
      return this[Headers];
    }
    async json() {
      return JSON.parse(await this.text());
    }
    get ok() {
      let status = this.status;
      return status >= 200 && status < 300;
    }
    static redirect(url, status) {
      return new Response(void 0, { headers: { location: url }, status: status || 302 });
    }
    set redirected(newRedirected) {
      this[Redirected] = newRedirected;
    }
    get redirected() {
      return this[Redirected];
    }
    get status() {
      return host.hostcall_resp_get_status(this[EdgioId]);
    }
    get statusText() {
      return host.hostcall_resp_get_reason(this[EdgioId]);
    }
    async text() {
      this[BodyUsed] = true;
      if (!this[BodyDefined]) {
        return "";
      }
      const body = await this.body.getReader().read();
      return new TextDecoder("utf-8").decode(body.value);
    }
    get type() {
      throw new Error(`${InternalErrorPrefix}The 'type' property is not supported by the Response class.`);
    }
    get url() {
      return this[Url];
    }
    get edgioId() {
      return this[EdgioId];
    }
    toJSON() {
      return {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers
      };
    }
    cloneWithoutBody() {
      const clone_id = host.hostcall_resp_clone_without_body(this[EdgioId]);
      const resp = new Response(null, {
        edgio: {
          id: clone_id
        }
      });
      resp[Url] = this[Url];
      resp[Redirected] = this[Redirected];
      return resp;
    }
  };
  globalThis.OpaqueRedirect = class extends globalThis.Response {
    constructor(edgioId, url) {
      super("", { edgio: { id: edgioId } });
      this[Headers] = {
        append: () => {
        },
        delete: () => {
        },
        entries: () => {
          return [];
        },
        forEach: () => {
        },
        get: () => {
          return null;
        },
        has: () => {
          return false;
        },
        keys: () => {
          return [];
        },
        set: () => {
        },
        values: () => {
          return [];
        }
      };
      this[Url] = url;
    }
    get ok() {
      return false;
    }
    get status() {
      return 0;
    }
  };
  class ResponseError extends Error {
    constructor(responseErrorCode) {
      super();
      this[ErrorCode] = responseErrorCode;
    }
    get code() {
      return this[ErrorCode];
    }
    get message() {
      return host.hostcall_resp_get_error_code_message(this[ErrorCode]);
    }
    toString() {
      return `${this.message} (code: ${this.code})`;
    }
  }
  class EdgioDict {
    constructor(namespace) {
      this[Namespace] = namespace;
    }
    get(key) {
      return host.hostcall_dict_get(this[Namespace], key);
    }
    getBase64Decoded(key) {
      return new Uint8Array(host.hostcall_dict_get_base64_decoded(this[Namespace], key));
    }
    has(key) {
      return host.hostcall_dict_check(this[Namespace], key);
    }
    keys() {
      return utility.dict_get_keys(this[Namespace]);
    }
    toJSON() {
      const json = {};
      for (const key of this.keys()) {
        json[key] = this.get(key);
      }
      return json;
    }
  }
  class EdgioSet {
    constructor(namespace) {
      this[Namespace] = namespace;
    }
    has(key) {
      return host.hostcall_unique_set_check(this[Namespace], key);
    }
    keys() {
      return utility.unique_set_get_keys(this[Namespace]);
    }
    toJSON() {
      return this.keys();
    }
  }
  class EdgioMetrics {
    startTimer(index) {
      return host.hostcall_metrics_start_timer(index);
    }
    stopTimer(timerId) {
      return host.hostcall_metrics_stop_timer(timerId);
    }
    add(index, value) {
      return host.hostcall_metrics_add(index, value);
    }
  }
  globalThis.edgio = {
    env: new EdgioDict(ENV_VAR_NAMESPACE_EDGIO_CONFIG),
    origins: new EdgioSet(ENV_VAR_NAMESPACE_EDGIO_ORIGINS),
    usrvar: new EdgioDict(ENV_VAR_NAMESPACE_EDGIO_USRVAR),
    metrics: new EdgioMetrics()
  };
  globalThis.module = {};
  globalThis.__dirname = "/";
  globalThis.__filename = "/index.js";
  globalThis.global = globalThis;
  const { TextEncoder, TextDecoder } = require_EncoderAndDecoderNodeJS_min();
  globalThis.TextDecoder = TextDecoder;
  globalThis.TextEncoder = TextEncoder;
  Object.defineProperties(globalThis.TextEncoder.prototype, {
    encoding: {
      get: function() {
        return "utf8";
      }
    }
  });
  let fetch_listeners = [];
  let waiting_on_listener_promise = false;
  let unhandled_rejection = null;
  let pending_fetches = /* @__PURE__ */ new Map();
  let respond_with_finished = false;
  let wait_until_used_counter = 0;
  let wait_until_finished_counter = 0;
  globalThis.addEventListener = function(type, listener, _options) {
    if (type === "fetch") {
      fetch_listeners.push(listener);
    } else {
      console.warn(`Unsupported event type: ${type}`);
    }
  };
  function expect_number_of_args(args, expected) {
    if (args.length !== expected) {
      throw new Error(`Expected ${expected} arguments, got ${args.length}`);
    }
  }
  function expect_min_number_of_args(args, expected) {
    if (args.length < expected) {
      throw new Error(`Expected at least ${expected} arguments, got ${args.length}`);
    }
  }
  function create_event_object(req) {
    return {
      type: "fetch",
      request: req,
      respondWith: function(responsePromise) {
        expect_number_of_args(arguments, 1);
        if (responsePromise instanceof Response) {
          let response = responsePromise;
          host.hostcall_debug("sdk.js respondWith: got response object, handle synchronously and return");
          host.hostcall_resp_send_to_client(response.edgioId);
          respond_with_finished = true;
          return void 0;
        }
        host.hostcall_debug("sdk.js respondWith: resolving response promise");
        Promise.resolve(responsePromise).then((response) => {
          host.hostcall_resp_send_to_client(response.edgioId);
          respond_with_finished = true;
          return response;
        }).catch((err) => {
          respond_with_finished = false;
          throw new Error("Failed to resolve respondWith promise: " + err);
        });
      },
      waitUntil: function(promise) {
        expect_number_of_args(arguments, 1);
        ++wait_until_used_counter;
        Promise.resolve(promise).then((response) => {
          ++wait_until_finished_counter;
          return response;
        }).catch((err) => {
          ++wait_until_finished_counter;
          throw new Error("Failed to resolve waitUntil promise: " + err);
        });
      }
    };
  }
  function parseCookie(cookie) {
    const parts = cookie.split("=");
    const key = parts[0].trim();
    const value = parts[1];
    return { key, value };
  }
  function processSetCookies(options, response) {
    let deduplicatedCookies = {};
    const existingCookies = options.headers.cookie;
    if (existingCookies) {
      const individualCookies = existingCookies.split(";");
      for (let i = 0; i < individualCookies.length; i++) {
        const { key, value } = parseCookie(individualCookies[i]);
        deduplicatedCookies[key] = value;
      }
    }
    let setCookies = response.headers.get("set-cookie") || [];
    if (!Array.isArray(setCookies)) {
      setCookies = [setCookies];
    }
    for (let i = 0; i < setCookies.length; i++) {
      const { key, value } = parseCookie(setCookies[i].split(";")[0]);
      deduplicatedCookies[key] = value;
    }
    const keys = Object.keys(deduplicatedCookies);
    if (keys.length > 0) {
      options.headers.cookie = "";
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = deduplicatedCookies[key];
        options.headers.cookie += `${key}=${value}${i < keys.length - 1 ? "; " : ""}`;
      }
    }
  }
  async function handleRedirect(originalUrl, options, redirectedCount, response) {
    const MAX_REDIRECTS = 5;
    const location = response.headers.get("location");
    if ([301, 302, 303, 307, 308].indexOf(response.status) < 0 || !location) {
      response[Url] = originalUrl;
      response.redirected = redirectedCount > 0;
      return response;
    }
    const redirect = options.redirect;
    if (redirect === "error") {
      throw new Error("redirect");
    }
    if (redirect === "manual") {
      return new globalThis.OpaqueRedirect(response.edgioId, originalUrl);
    }
    if (++redirectedCount > MAX_REDIRECTS) {
      throw new Error(`fetch(${originalUrl}) exceeded the limit of ${MAX_REDIRECTS} redirects.`);
    }
    processSetCookies(options, response);
    const newResponse = await issueFetch(location, options, redirectedCount);
    return newResponse;
  }
  async function issueFetch(urlOrRequest, options, redirectedCount) {
    let req;
    if (urlOrRequest instanceof Request) {
      req = urlOrRequest;
    } else {
      req = new Request(urlOrRequest, options);
    }
    try {
      host.hostcall_req_set_fetch_origin(req.edgioId, options.edgio.origin);
    } catch {
      throw new Error(`Invalid edgio.origin specified. Must be one of: ${edgio.origins.keys().join(",")}`);
    }
    host.hostcall_req_fetch_async(req.edgioId);
    let resolve;
    let reject;
    const promise = new Promise((promise_resolve, promise_reject) => {
      resolve = promise_resolve;
      reject = promise_reject;
    });
    pending_fetches.set(req.edgioId, {
      promise,
      resolve,
      reject
    });
    const request_url = req.url;
    const response = await promise;
    return handleRedirect(request_url, options, redirectedCount, response);
  }
  globalThis.fetch = async function(urlOrRequest, options) {
    expect_min_number_of_args(arguments, 1);
    options = options || {};
    if (!options.redirect) {
      options.redirect = "follow";
    }
    if (!options.headers) {
      options.headers = {};
    }
    if (!options.edgio) {
      options.edgio = {};
    }
    const validRedirects = ["error", "follow", "manual"];
    if (validRedirects.indexOf(options.redirect) < 0) {
      throw new Error(`redirect must be one of "${validRedirects.join(", ")}", not "${options.redirect}"`);
    }
    if (!options.edgio.origin) {
      throw new Error(`edgio.origin must be specified as a fetch option. Must be one of: ${edgio.origins.keys().join(",")}`);
    }
    return issueFetch(urlOrRequest, options, 0);
  };
  function main(edgioRequestId2) {
    const path = edgio.env.get("__EDGE_FUNCTION_PATH__");
    const edgeFunction = edgeFunctions.get(path);
    if (!edgeFunction) {
      throw new Error(`No edge function found for path: ${path}`);
    }
    edgeFunction().bind(globalThis)();
    if (fetch_listeners.length === 0) {
      host.hostcall_debug("No fetch listeners, returning immediately");
      return;
    }
    host.hostcall_debug(`Got ${fetch_listeners.length} fetch listeners`);
    const req = new Request(null, {
      edgio: {
        id: edgioRequestId2
      }
    });
    const event_object = create_event_object(req);
    function jobs_are_not_pending() {
      return respond_with_finished && wait_until_finished_counter >= wait_until_used_counter;
    }
    while (true) {
      while (!waiting_on_listener_promise && fetch_listeners.length > 0) {
        const listener = fetch_listeners.shift();
        const promise = listener(event_object);
        if (promise instanceof Promise) {
          waiting_on_listener_promise = true;
          promise.then(() => {
            waiting_on_listener_promise = false;
          }).catch((err) => {
            waiting_on_listener_promise = false;
            unhandled_rejection = err;
          });
        }
        if (jobs_are_not_pending()) {
          host.hostcall_debug("breaking the loop - no more jobs (1)");
          return;
        }
      }
      host.hostcall_debug("Executing pending jobs...");
      utility.execute_pending();
      if (unhandled_rejection) {
        const err = unhandled_rejection;
        unhandled_rejection = null;
        throw err;
      }
      if (pending_fetches.size === 0) {
        if (fetch_listeners.length === 0 && !waiting_on_listener_promise) {
          return;
        }
      } else {
        const [is_response, req_id, resp_id_or_err_code] = host.hostcall_resp_await_next();
        host.hostcall_debug(`sdk.js->hostcall_resp_await_next: is_response(${is_response}), req_id(${req_id}), resp_id_or_err_code(${resp_id_or_err_code})`);
        const pending_fetch = pending_fetches.get(req_id);
        if (!pending_fetch) {
          throw new Error(`No pending fetch for ID ${req_id}`);
        }
        pending_fetches.delete(req_id);
        const { resolve, reject } = pending_fetch;
        if (is_response) {
          host.hostcall_debug("sdk.js: creating Response");
          const resp = new Response(null, {
            edgio: {
              id: resp_id_or_err_code
            }
          });
          resolve(resp);
        } else {
          host.hostcall_debug("sdk.js: creating ResponseError");
          const err = new ResponseError(resp_id_or_err_code);
          reject(err);
        }
      }
      if (jobs_are_not_pending()) {
        host.hostcall_debug("breaking the loop - no more jobs (2)");
        return;
      }
    }
  }
  main(edgioRequestId);
};
//# sourceMappingURL=sdk.js.map
