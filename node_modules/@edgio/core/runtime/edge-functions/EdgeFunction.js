"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EdgeFunctionMetrics_1 = __importDefault(require("./EdgeFunctionMetrics"));
const EdgeFunctionReason_1 = __importDefault(require("./EdgeFunctionReason"));
const EdgeFunctionRequest_1 = __importDefault(require("./EdgeFunctionRequest"));
const EdgeFunctionResponse_1 = __importDefault(require("./EdgeFunctionResponse"));
const EdgeFunctionError_1 = __importDefault(require("./EdgeFunctionError"));
const EdgeFunctionHeaders_1 = __importDefault(require("./EdgeFunctionHeaders"));
const EdgeFunctionsWasmManager_1 = __importDefault(require("./EdgeFunctionsWasmManager"));
const WasmProgram_1 = __importStar(require("./WasmProgram"));
const decodeBase64Validated_1 = __importDefault(require("../../utils/decodeBase64Validated"));
const buffer_1 = require("buffer");
// Matches the definition of the `fetch_response_error` enum from mod_wasm.
const FetchResponseError = {
    UNKNOWN: 0,
    CONNECT_FAILED: 1,
    CONNECT_TIMEOUT: 2,
    SSL_CONNECT_FAILED: 3,
    SSL_CERTIFICATE_VALIDATION_FAILED: 4,
    BAD_REQUEST: 5,
    BAD_RESPONSE: 6,
    TIMEOUT: 7,
    REENTRANT_LOOP: 8,
    FORBIDDEN: 9,
};
// Dictionary namespaces used here, in sailfish and sdk.js
const ENV_VAR_NAMESPACE_EDGIO_CONFIG = 'edgio-config';
const ENV_VAR_NAMESPACE_EDGIO_ORIGINS = 'edgio-origins';
const ENV_VAR_NAMESPACE_EDGIO_USRVAR = 'edgio-usrvar';
// Matches the definition of the `fetch_response_error` enum from mod_wasm.
const FetchResponseErrorFriendlyMessage = {
    [FetchResponseError.UNKNOWN]: 'Unknown',
    [FetchResponseError.CONNECT_FAILED]: 'Connect Failed',
    [FetchResponseError.CONNECT_TIMEOUT]: 'Connect Timeout',
    [FetchResponseError.SSL_CONNECT_FAILED]: 'SSL Connect Failed',
    [FetchResponseError.SSL_CERTIFICATE_VALIDATION_FAILED]: 'SSL Certificate Validation Failed',
    [FetchResponseError.BAD_REQUEST]: 'Bad Request',
    [FetchResponseError.BAD_RESPONSE]: 'Bad Response',
    [FetchResponseError.TIMEOUT]: 'Timeout',
    [FetchResponseError.REENTRANT_LOOP]: 'Reentrant loop',
    [FetchResponseError.FORBIDDEN]: 'Forbidden',
};
function getFetchResponseErrorFriendlyMessage(errorCode) {
    return FetchResponseErrorFriendlyMessage[errorCode];
}
// Constants used to limit the stdout and stderror output from the guest.
const overflow_message = '<truncated>';
const MAX_OUT_BYTES = 2048; // should be same as value in mod_wasm_pconf.cc
const MAX_PANIC_BYTES = 512; // should be same as value in mod_wasm_pconf.cc
/// Encapsulates the execution of JavaScript edge functions by leveraging
/// the QuickJS WASM runtime function.
class EdgeFunction extends WasmProgram_1.default {
    /// Constructs a new EdgeFunction instance for the given parent and parameters.
    constructor(parent, params) {
        super();
        this.response = new EdgeFunctionResponse_1.default({});
        this.metrics = new EdgeFunctionMetrics_1.default();
        // In Sailfish, the request and response IDs are used to identify the request and response.
        // In our case here, we only have one downstream request and response objects per EdgeFunction
        // instance so we can use any ID as long as it's stable. Any upstream requests coming out of
        // the edge function will have their own IDs following these "base" IDs.
        this.DOWNSTREAM_REQUEST_ID = 0;
        // TODO: Response ID is returned by edge function, this const should not be necessary
        this.DOWNSTREAM_RESPONSE_ID = 0;
        this.params = params;
        this.parent = parent;
        this.out_written_bytes = 0;
    }
    /// Singleton function managing the lifetime of the QuickJs Core WASM function
    static async getQuickJsCore() {
        if (!EdgeFunction.QuickJsModule) {
            // Load the WASM QuickJS runtime once per lifetime of the instance.
            // The WASM QuickJS runtime is a WASM module that contains the QuickJS interpreter
            // and our code that implements the JavaScript API available to the end users.
            // It is built from Sailfish repository, mod_wasm sources, and not checked in.
            const wasmBytes = await EdgeFunctionsWasmManager_1.default.getQuickjsRuntimeBytes();
            EdgeFunction.QuickJsModule = new WebAssembly.Module(wasmBytes);
        }
        return EdgeFunction.QuickJsModule;
    }
    getPanicString() {
        return this.panicString || this.guestErrorMessage || 'No stack information available.';
    }
    async run() {
        const module = await EdgeFunction.getQuickJsCore();
        const importObject = this.getQuickJsImportObject();
        const instance = new WebAssembly.Instance(module, importObject);
        this.setInstance(instance);
        // TODO: Response ID is returned by edge function event.respondWith(), the 2nd parameter should not be necessary
        // `run` is the entry point of the WASM module.
        // Please consult the Sailfish repository for the implementation of the `run` function.
        // status = 0 OK, status = 2 exception, see quickjs-wasm/quickjs-runtime/src/lib.rs for values
        // @ts-ignore
        const status = this.instance.exports.run(this.DOWNSTREAM_REQUEST_ID, this.DOWNSTREAM_RESPONSE_ID);
        if (status !== EdgeFunctionError_1.default.Ok) {
            this.funDebug('EdgeFunction.run() threw exception');
            return status;
        }
        this.metrics.write(this.funDebug.bind(this));
        // If the downstream request was a HEAD, remove the body from the response.
        // This is done here (after the edge function has fully executed) in order
        // to match the behavior of mod_wasm.
        if (this.params.request.method == 'HEAD') {
            this.response.body = buffer_1.Buffer.from('');
        }
        this.funDebug('EdgeFunction.run() finished with status code', this.response.statusCode);
        return this.response;
    }
    funDebug(...args) {
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (buffer_1.Buffer.isBuffer(arg)) {
                this.parent.writeToDebugStream(arg);
            }
            else if (typeof (arg === null || arg === void 0 ? void 0 : arg.toString) === 'function') {
                this.parent.writeToDebugStream(buffer_1.Buffer.from(arg.toString()));
            }
            else if (typeof arg === 'undefined') {
                this.parent.writeToDebugStream(buffer_1.Buffer.from('undefined'));
            }
            else {
                this.parent.writeToDebugStream(buffer_1.Buffer.from(`[unhandled type ${typeof arg}]`));
            }
            if (i < args.length - 1) {
                this.parent.writeToDebugStream(buffer_1.Buffer.from(' '));
            }
        }
        this.parent.writeToDebugStream(buffer_1.Buffer.from('\n'));
    }
    /// Creates a buffer of uint32 string lengths to be passed to copyDataToGuestMemory().
    stringLengthsToBuffer(values) {
        const uint32Size = 4;
        const itemCount = values.length;
        const arr = new ArrayBuffer(uint32Size * itemCount);
        const view = new DataView(arr);
        for (let i = 0; i < itemCount; i++) {
            view.setUint32(i * uint32Size, values[i].length, true); // true = little endian for Intel x86
        }
        return buffer_1.Buffer.from(new Uint8Array(arr));
    }
    /// Returns the import object for the QuickJS WASM function which includes both WASI
    /// interface and custom hostcalls as defined in the Sailfish repository.
    getQuickJsImportObject() {
        // Set of all the requests that the edge function has access to.
        let requests = new Map();
        requests.set(this.DOWNSTREAM_REQUEST_ID, EdgeFunctionRequest_1.default.createFromEdgeFunctionParams(this.params));
        // Next upstream request IDs start from the ID after the base "downstream" request ID.
        let nextUpstreamRequestId = this.DOWNSTREAM_REQUEST_ID + 1;
        let responses = new Map();
        // TODO: Response ID is returned by edge function, this empty response should not be necessary
        responses.set(this.DOWNSTREAM_RESPONSE_ID, this.response);
        // Next upstream response IDs start from the ID after the base "downstream" response ID.
        let nextUpstreamResponseId = this.DOWNSTREAM_RESPONSE_ID + 1;
        const getRequest = (id) => {
            const request = requests.get(id);
            if (!request) {
                return {
                    status: WasmProgram_1.wasm_status.invalid_id,
                    message: `Invalid response ID provided ${id}`,
                };
            }
            return request;
        };
        const getResponse = (id) => {
            const response = responses.get(id);
            if (!response) {
                return {
                    status: WasmProgram_1.wasm_status.invalid_id,
                    message: `Invalid response ID provided ${id}`,
                };
            }
            return response;
        };
        // Create "constant" timestamp returned by clock_time_get()
        const startTimeNs = BigInt(Date.now() * 1000);
        const handleWasmError = (error) => {
            this.lastHostErrorMessage = error.message;
            return error.status;
        };
        const is_allowed_usrvar_name = (name) => {
            const lowerName = name.toLowerCase();
            return (lowerName.startsWith('geo_') ||
                lowerName.startsWith('usrvar_') ||
                lowerName.startsWith('virt_') ||
                lowerName.startsWith('wurfl_'));
        };
        return {
            env: {
                hostcall_get_last_host_error_message: (message_offset, message_len) => {
                    if (!this.lastHostErrorMessage) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    return this.setStringInGuestMemory(message_offset, message_len, this.lastHostErrorMessage);
                },
                hostcall_set_guest_error_message: (message_offset, message_len) => {
                    const memory = this.getGuestMemory();
                    this.guestErrorMessage = this.getStringFromGuestMemory(memory, message_offset, message_len);
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_dict_check: (ns_offset, ns_len, name_offset, name_len) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_USRVAR) {
                        const name = this.getStringFromGuestMemory(memory, name_offset, name_len);
                        if (is_allowed_usrvar_name(name) && this.params.usrVars.has(name.toLowerCase()))
                            return WasmProgram_1.wasm_status.ok;
                        else
                            return WasmProgram_1.wasm_status.not_found;
                    }
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_CONFIG) {
                        const name = this.getStringFromGuestMemory(memory, name_offset, name_len);
                        return this.params.envVars.has(name) ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                    }
                    return handleWasmError({
                        status: WasmProgram_1.wasm_status.not_found,
                        message: `Namespace ${ns} does not exist`,
                    });
                },
                hostcall_dict_get: (ns_offset, ns_len, name_offset, name_len, value_offset, value_len_offset) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_USRVAR) {
                        const name = this.getStringFromGuestMemory(memory, name_offset, name_len).toLowerCase();
                        if (is_allowed_usrvar_name(name) && this.params.usrVars.has(name)) {
                            return this.setStringInGuestMemory(value_offset, value_len_offset, this.params.usrVars.get(name));
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_CONFIG) {
                        const name = this.getStringFromGuestMemory(memory, name_offset, name_len);
                        if (this.params.envVars.has(name)) {
                            return this.setStringInGuestMemory(value_offset, value_len_offset, this.params.envVars.get(name));
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    return handleWasmError({
                        status: WasmProgram_1.wasm_status.not_found,
                        message: `Namespace ${ns} does not exist`,
                    });
                },
                hostcall_dict_get_base64_decoded: (ns_offset, ns_len, name_offset, name_len, value_offset, value_len_offset) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_CONFIG) {
                        const name = this.getStringFromGuestMemory(memory, name_offset, name_len);
                        if (this.params.envVars.has(name)) {
                            const envVarValue = this.params.envVars.get(name);
                            // Attempt to (validate) and decode, then write to guest.
                            try {
                                let decodedValue = (0, decodeBase64Validated_1.default)(envVarValue);
                                return this.copyDataToGuestMemory(decodedValue, value_offset, value_len_offset);
                            }
                            catch (e) {
                                return handleWasmError({
                                    status: WasmProgram_1.wasm_status.invalid_argument,
                                    message: `Failed to decode value as base64: ${envVarValue}`,
                                });
                            }
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    return handleWasmError({
                        status: WasmProgram_1.wasm_status.not_found,
                        message: `Namespace ${ns} does not exist`,
                    });
                },
                hostcall_dict_get_key_by_idx: (ns_offset, ns_len, idx, key_offset, key_len_offset) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_USRVAR) {
                        const keys = Array.from(this.params.usrVars.keys());
                        let foundIdx = 0;
                        // We only count the indeces if the key is allowed.
                        for (let i = 0; i < keys.length; i++) {
                            const key = keys[i];
                            if (is_allowed_usrvar_name(key.toLowerCase())) {
                                if (foundIdx === idx) {
                                    let writeResult = this.setStringInGuestMemory(key_offset, key_len_offset, key);
                                    return writeResult;
                                }
                                foundIdx++;
                            }
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    if (ns === ENV_VAR_NAMESPACE_EDGIO_CONFIG) {
                        const envVarsCount = Array.from(this.params.envVars.keys()).length;
                        if (idx < envVarsCount) {
                            let writeResult = this.setStringInGuestMemory(key_offset, key_len_offset, Array.from(this.params.envVars.keys())[idx]);
                            return writeResult;
                        }
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    return handleWasmError({
                        status: WasmProgram_1.wasm_status.not_found,
                        message: `Namespace ${ns} does not exist`,
                    });
                },
                hostcall_unique_set_check: (ns_offset, ns_len, name_offset, name_len) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    // Connascence of algorithm with the `hostcall_dict_check` function in the Sailfish.
                    if (ns !== ENV_VAR_NAMESPACE_EDGIO_ORIGINS) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.not_found,
                            message: `Namespace ${ns} does not exist`,
                        });
                    }
                    const name = this.getStringFromGuestMemory(memory, name_offset, name_len);
                    return this.params.origins.find(x => x.name === name) !== undefined
                        ? WasmProgram_1.wasm_status.ok
                        : WasmProgram_1.wasm_status.not_found;
                },
                hostcall_unique_set_get_key_by_idx: (ns_offset, ns_len, idx, key_offset, key_len_offset) => {
                    const memory = this.getGuestMemory();
                    const ns = this.getStringFromGuestMemory(memory, ns_offset, ns_len);
                    // Connascence of algorithm with the `hostcall_unique_set_get_key_by_idx` function in the Sailfish.
                    if (ns !== ENV_VAR_NAMESPACE_EDGIO_ORIGINS) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.not_found,
                            message: `Namespace ${ns} does not exist`,
                        });
                    }
                    const origins = this.params.origins;
                    if (idx < origins.length) {
                        let writeResult = this.setStringInGuestMemory(key_offset, key_len_offset, origins[idx].name || `Undefined origin name at index ${idx}`);
                        return writeResult;
                    }
                    return WasmProgram_1.wasm_status.not_found;
                },
                // Create a request object
                hostcall_req_create: (method_offset, method_len, url_offset, url_len, req_id_offset) => {
                    const memory = this.getGuestMemory();
                    const method = this.getStringFromGuestMemory(memory, method_offset, method_len);
                    const url = this.getStringFromGuestMemory(memory, url_offset, url_len);
                    const uri_validate_result = EdgeFunctionRequest_1.default.validate_uri(url);
                    if (uri_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(uri_validate_result);
                    }
                    // Create new request object.
                    const request = EdgeFunctionRequest_1.default.createFromMethodAndUrl(method, url);
                    const id = nextUpstreamRequestId++;
                    memory.setUint32(req_id_offset, id);
                    requests.set(id, request);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Clone request object
                hostcall_req_clone_without_body: (id, clone_id_offset) => {
                    const memory = this.getGuestMemory();
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const clone_request = EdgeFunctionRequest_1.default.createFromRequest(request);
                    const clone_id = nextUpstreamRequestId++;
                    memory.setUint32(clone_id_offset, clone_id);
                    requests.set(clone_id, clone_request);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Create a response object with status code
                hostcall_resp_create: (status, resp_id_offset) => {
                    // Per https://developer.mozilla.org/en-US/docs/Web/HTTP/Status, status codes are
                    // between 100 and 599.
                    if (status < 100 || status > 599) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Invalid status code ${status}`,
                        });
                    }
                    const response = new EdgeFunctionResponse_1.default({
                        statusCode: status,
                    });
                    const id = nextUpstreamResponseId++;
                    const memory = this.getGuestMemory();
                    memory.setUint32(resp_id_offset, id);
                    responses.set(id, response);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Clone response object
                hostcall_resp_clone_without_body: (id, clone_id_offset) => {
                    const memory = this.getGuestMemory();
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const clone_response = EdgeFunctionResponse_1.default.createFromResponse(response);
                    const clone_id = nextUpstreamResponseId++;
                    memory.setUint32(clone_id_offset, clone_id);
                    responses.set(clone_id, clone_response);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Return the response
                hostcall_resp_send_to_client: (id) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    if (response.respond_called) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Outbound response already set',
                        });
                    }
                    response.respond_called = true;
                    this.funDebug('hostcall_resp_send_to_client()', id);
                    this.response = response;
                    return WasmProgram_1.wasm_status.ok;
                },
                // Initiate an asynchronous fetch
                hostcall_req_fetch_async: (id) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetch_called) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Can not modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    request.fetch_called = true;
                    // This is already checked in hostcall_req_set_fetch_origin,
                    // however this must also be checked in this hostcall in case
                    // the other hostcall is not called first (e.g. in third-party wasm functions).
                    // Connascence of algorithm with the `hostcall_req_fetch_async` function in the Sailfish.
                    if (request.fetchOrigin === undefined) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: `Fetch failed: No fetch origin was set`,
                        });
                    }
                    if (!this.params.origins.find(x => x.name === request.fetchOrigin) === undefined) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: `Fetch failed: fetch origin "${request.fetchOrigin}" not found`,
                        });
                    }
                    // Limit fetches to these methods. Must be the same list
                    // as in sailfish/src/modules/wasm/hostcalls/request.cc
                    const METHODS = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT'];
                    if (METHODS.indexOf(request.method) === -1) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: `Fetch failed: Method '${request.method}' is not supported.`,
                        });
                    }
                    this.parent.fetchAsync(id, request.url, {
                        method: request.method,
                        headers: request.getHeaders(),
                        body: request.rawBody,
                        fetchOrigin: request.fetchOrigin,
                    });
                    return WasmProgram_1.wasm_status.ok;
                },
                // wait for the next response or response error to arrive
                hostcall_resp_await_next: (pending_request_offset, response_or_response_error_code_offset, result_type_offset) => {
                    // Synchronously waits for the next ready response.
                    const { requestId, ...response } = this.parent.waitNextReadyResponseSync();
                    const memory = this.getGuestMemory();
                    memory.setUint32(pending_request_offset, requestId);
                    if (response.response) {
                        const responseId = nextUpstreamResponseId++;
                        this.funDebug('hostcall_resp_await_next()', requestId, responseId);
                        memory.setUint32(response_or_response_error_code_offset, responseId);
                        memory.setUint32(result_type_offset, 1); // Response.
                        // Convert to EdgeFunctionResponse for consistency
                        responses.set(responseId, new EdgeFunctionResponse_1.default(response.response));
                    }
                    else {
                        this.funDebug('hostcall_resp_await_next() error', requestId, JSON.stringify(response));
                        // HACK: We _always_ return mod_wasm CONNECT_FAILED instead of attempting
                        // to map node-fetch failures onto mod_wasm's response error codes.
                        memory.setUint32(response_or_response_error_code_offset, FetchResponseError.CONNECT_FAILED);
                        memory.setUint32(result_type_offset, 0); // Response Error.
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get the request uri
                hostcall_req_get_uri: (id, uri_offset, uri_length_offset) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const data = new TextEncoder().encode(request.url);
                    this.funDebug(`hostcall_req_get_uri(${id}) : ${request.url}`);
                    return this.copyDataToGuestMemory(data, uri_offset, uri_length_offset);
                },
                // Get the request path
                hostcall_req_get_path: (id, data_offset, len_offset) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const data = new TextEncoder().encode(request.path);
                    this.funDebug(`hostcall_req_get_path(${id}) : ${request.path}`);
                    return this.copyDataToGuestMemory(data, data_offset, len_offset);
                },
                // Get the request method
                hostcall_req_get_method: (id, data_offset, len_offset) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const data = new TextEncoder().encode(request.method);
                    this.funDebug(`hostcall_req_get_method(${id}) : ${request.method}`);
                    return this.copyDataToGuestMemory(data, data_offset, len_offset);
                },
                // Set the request method
                hostcall_req_set_method: (id, data_offset, len) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetch_called) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Can not modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const method = this.getStringFromGuestMemory(memory, data_offset, len);
                    request.method = method;
                    this.funDebug('hostcall_req_set_method()', id, method);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Set the request uri
                hostcall_req_set_uri: (id, data_offset, len) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetch_called) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Can not modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const uri = this.getStringFromGuestMemory(memory, data_offset, len);
                    const uri_validate_result = EdgeFunctionRequest_1.default.validate_uri(uri);
                    if (uri_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(uri_validate_result);
                    }
                    request.url = uri;
                    this.funDebug('hostcall_req_set_uri()', id, uri);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Set the fetch origin
                hostcall_req_set_fetch_origin: (id, origin_offset, len) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const fetchOrigin = this.getStringFromGuestMemory(memory, origin_offset, len);
                    const origin = this.params.origins.find(x => x.name === fetchOrigin);
                    if (origin === undefined) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Undefined fetch origin "${fetchOrigin}"`,
                        });
                    }
                    request.fetchOrigin = origin;
                    return WasmProgram_1.wasm_status.ok;
                },
                // Set the request body
                hostcall_req_set_body: (id, data_offset, len) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetch_called) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Can not modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const body = memory.slice(data_offset, data_offset + len);
                    request.rawBody = buffer_1.Buffer.from(body);
                    this.funDebug('hostcall_req_set_body()', id, body);
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_req_get_body: (id, data_offset, len_offset) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    this.funDebug('hostcall_req_get_body()', id);
                    return this.copyDataToGuestMemory(request.rawBody || buffer_1.Buffer.alloc(0), data_offset, len_offset);
                },
                // Set the response http status code
                hostcall_resp_set_status: (id, status) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    if (response.respond_called) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Can not modify a response that has been sent, use .cloneWithoutBody().',
                        });
                    }
                    this.funDebug('hostcall_resp_set_status()', id, status);
                    response.statusCode = status;
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get the response http status code
                hostcall_resp_get_status: (id, status_offset) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    this.funDebug('hostcall_resp_get_status()', id, response.statusCode);
                    const memory = this.getGuestMemory();
                    memory.setUint32(status_offset, response.statusCode);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get the response http status reason text
                hostcall_resp_get_reason: (id, data_offset, len_offset) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const reason = (0, EdgeFunctionReason_1.default)(response.statusCode);
                    this.funDebug('hostcall_resp_get_reason()', id, reason);
                    const data = new TextEncoder().encode(reason);
                    return this.copyDataToGuestMemory(data, data_offset, len_offset);
                },
                // Set the response body
                hostcall_resp_set_body: (id, ptr, len) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    if (response.respond_called) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Can not modify a response that has been sent, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const body = memory.slice(ptr, ptr + len);
                    response.body = buffer_1.Buffer.from(body);
                    this.funDebug('hostcall_resp_set_body()', id, body);
                    return WasmProgram_1.wasm_status.ok;
                },
                // panic callback
                hostcall_panic_hook: (msg_offset, msg_length) => {
                    const memory = this.getGuestMemory();
                    const msg = this.getStringFromGuestMemory(memory, msg_offset, msg_length);
                    this.panicString = msg;
                    // We also write the panic message to stderr. In Sailfish we limit the panic
                    // to 512 bytes, but here we just inject <truncated> into the message so the
                    // user knows it will be truncated in production. Since there can only be one
                    // panic per edge function run, we do not need to accumulate the panic_written_bytes.
                    const msgAsBuf = buffer_1.Buffer.from(msg);
                    if (msg_length + overflow_message.length >= MAX_PANIC_BYTES) {
                        this.parent.writeToStderr(msgAsBuf.slice(0, MAX_PANIC_BYTES));
                        this.parent.writeToStderr(buffer_1.Buffer.from(overflow_message));
                        this.parent.writeToStderr(msgAsBuf.slice(MAX_PANIC_BYTES));
                    }
                    else {
                        this.parent.writeToStderr(msgAsBuf);
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get a request header name by index
                hostcall_req_get_header_name_by_idx: (id, idx_offset, key_offset, key_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    // The implementation in CLI is different from the Sailfish implementation
                    // because we filter the headers in EdgeFunctionHeaders to only return the
                    // headers that are allowed to be read. Hence we only read the index and
                    // never need to update it.
                    const memory = this.getGuestMemory();
                    const idx = memory.getUint32(idx_offset);
                    const headerName = request.getHeaderNameByIdx(idx);
                    // If there is no header or the header is not allowed to be read, return not found
                    if (!headerName || !EdgeFunctionHeaders_1.default.is_allowed_read_header_name(headerName)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    this.funDebug('hostcall_req_get_header_name_by_idx()', idx, headerName);
                    return this.copyDataToGuestMemory(buffer_1.Buffer.from(headerName), key_offset, key_length);
                },
                // Pass in a header name and return the header's values as string array
                // or an exception if the header name is not found.
                hostcall_req_get_header_values: (id, key_offset, key_length, sizes_offset, // ptr to sizes array
                sizes_length_offset, // ptr to length of sizes array
                values_offset, // ptr to values array
                values_length_offset // ptr to length of values array
                ) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    // We are pretending that non-readable headers do not exist.
                    if (!EdgeFunctionHeaders_1.default.is_allowed_read_header_name(key)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    let headerValues = request.getHeader(key);
                    if (typeof headerValues === 'string') {
                        // Ensure the result is always an array of string
                        headerValues = [headerValues];
                    }
                    if (!Array.isArray(headerValues)) {
                        // If not a string or array, return not found
                        this.funDebug(`hostcall_req_get_header_values() id: ${id} key '${key}' not found`);
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    // Put all of the lengths into a single buffer so we can call a single copyDataToGuestMemory()
                    let rc = this.copyDataToGuestMemory(this.stringLengthsToBuffer(headerValues), sizes_offset, sizes_length_offset);
                    if (rc !== WasmProgram_1.wasm_status.ok)
                        return rc;
                    // Put all of the strings into a single buffer so we can call a single copyDataToGuestMemory()
                    return this.copyDataToGuestMemory(buffer_1.Buffer.from(headerValues.join('')), values_offset, values_length_offset);
                },
                // Set a request header
                hostcall_req_set_header: (id, key_offset, key_length, val_offset, val_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    if (request.fetch_called) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Can not modify a request that has been fetched, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    const key_validate_result = EdgeFunctionHeaders_1.default.validate_header_name(key);
                    if (key_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(key_validate_result);
                    }
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Header ${key} not allowed to be set.`,
                        });
                    }
                    const val = this.getStringFromGuestMemory(memory, val_offset, val_length);
                    const val_validate_result = EdgeFunctionHeaders_1.default.validate_header_value(val);
                    if (val_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(val_validate_result);
                    }
                    this.funDebug(`hostcall_req_set_header() ${id}, '${key}' : ${JSON.stringify(val)}`);
                    request.setHeader(key, val);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Insert/append a request header
                hostcall_req_append_header: (id, key_offset, key_length, val_offset, val_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    const key_validate_result = EdgeFunctionHeaders_1.default.validate_header_name(key);
                    if (key_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(key_validate_result);
                    }
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        throw new WebAssembly.RuntimeError(`Header ${key} not allowed to be appended.`);
                    }
                    const val = this.getStringFromGuestMemory(memory, val_offset, val_length);
                    const val_validate_result = EdgeFunctionHeaders_1.default.validate_header_value(val);
                    if (val_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(val_validate_result);
                    }
                    this.funDebug(`hostcall_req_append_header() ${id}, '${key}' : ${JSON.stringify(val)}`);
                    request.appendHeader(key, val);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Remove a request header
                hostcall_req_remove_header: (id, key_offset, key_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Header ${key} not allowed to be removed.`,
                        });
                    }
                    this.funDebug(`hostcall_req_remove_header() ${id}, '${key}'`);
                    return request.removeHeader(key) ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                },
                // Check that a request header exists
                hostcall_req_check_header: (id, key_offset, key_length) => {
                    const request = getRequest(id);
                    if (request instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(request);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    // Not allowed to be read so treat it as if it doesn't exist.
                    if (!EdgeFunctionHeaders_1.default.is_allowed_read_header_name(key)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    const exists = request.getHeader(key) !== undefined;
                    this.funDebug(`hostcall_req_check_header() ${id}, '${key}' returns: ${exists}`);
                    return exists ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                },
                // Get a response header name by index
                hostcall_resp_get_header_name_by_idx: (id, idx_offset, key_offset, key_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    // The implementation in CLI is different from the Sailfish implementation
                    // because we filter the headers in EdgeFunctionHeaders to only return the
                    // headers that are allowed to be read. Hence we only read the index and
                    // never need to update it.
                    const memory = this.getGuestMemory();
                    const idx = memory.getUint32(idx_offset);
                    const headerName = response.headers.key(idx);
                    if (!headerName || !EdgeFunctionHeaders_1.default.is_allowed_read_header_name(headerName)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    this.funDebug('hostcall_resp_get_header_name_by_idx()', idx, headerName);
                    return this.copyDataToGuestMemory(buffer_1.Buffer.from(headerName), key_offset, key_length);
                },
                // Pass in a header name and return the header's values as string array
                // or an exception if the header name is not found.
                hostcall_resp_get_header_values: (id, key_offset, key_length, sizes_offset, // ptr to sizes array
                sizes_length_offset, // ptr to length of sizes array
                values_offset, // ptr to values array
                values_length_offset // ptr to length of values array
                ) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    // We are pretending that non-readable headers do not exist.
                    if (!EdgeFunctionHeaders_1.default.is_allowed_read_header_name(key)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    let headerValues = response.headers.get(key);
                    if (typeof headerValues === 'string') {
                        // Ensure the result is always an array of string
                        headerValues = [headerValues];
                    }
                    if (!Array.isArray(headerValues)) {
                        // If not a string or array, return not found
                        this.funDebug(`hostcall_resp_get_header_values() id: ${id} key '${key}' not found`);
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    // Put all of the lengths into a single buffer so we can call a single copyDataToGuestMemory()
                    let rc = this.copyDataToGuestMemory(this.stringLengthsToBuffer(headerValues), sizes_offset, sizes_length_offset);
                    if (rc !== WasmProgram_1.wasm_status.ok)
                        return rc;
                    // Put all of the strings into a single buffer so we can call a single copyDataToGuestMemory()
                    return this.copyDataToGuestMemory(buffer_1.Buffer.from(headerValues.join('')), values_offset, values_length_offset);
                },
                // Set a response header
                hostcall_resp_set_header: (id, key_offset, key_length, val_offset, val_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    if (response.respond_called) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_operation,
                            message: 'Can not modify a response that has been sent, use .cloneWithoutBody().',
                        });
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    const key_validate_result = EdgeFunctionHeaders_1.default.validate_header_name(key);
                    if (key_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(key_validate_result);
                    }
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        throw new WebAssembly.RuntimeError(`Header ${key} not allowed to be set.`);
                    }
                    const val = this.getStringFromGuestMemory(memory, val_offset, val_length);
                    const val_validate_result = EdgeFunctionHeaders_1.default.validate_header_value(val);
                    if (val_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(val_validate_result);
                    }
                    this.funDebug(`hostcall_resp_set_header() ${id}, '${key}' : ${JSON.stringify(val)}`);
                    response.headers.set(key, val);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Insert/append a response header
                hostcall_resp_append_header: (id, key_offset, key_length, val_offset, val_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    const key_validate_result = EdgeFunctionHeaders_1.default.validate_header_name(key);
                    if (key_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(key_validate_result);
                    }
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Header ${key} not allowed to be appended.`,
                        });
                    }
                    const val = this.getStringFromGuestMemory(memory, val_offset, val_length);
                    const val_validate_result = EdgeFunctionHeaders_1.default.validate_header_value(val);
                    if (val_validate_result.status !== WasmProgram_1.wasm_status.ok) {
                        return handleWasmError(val_validate_result);
                    }
                    this.funDebug(`hostcall_resp_append_header() ${id}, '${key}' : ${JSON.stringify(val)}`);
                    response.headers.append(key, val);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Remove a response header
                hostcall_resp_remove_header: (id, key_offset, key_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    if (!EdgeFunctionHeaders_1.default.is_allowed_write_header_name(key)) {
                        throw new WebAssembly.RuntimeError(`Header ${key} not allowed to be removed.`);
                    }
                    this.funDebug(`hostcall_resp_remove_header() ${id}, '${key}'`);
                    return response.headers.remove(key) ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                },
                // Check that a response header exists
                hostcall_resp_check_header: (id, key_offset, key_length) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    const memory = this.getGuestMemory();
                    const key = this.getStringFromGuestMemory(memory, key_offset, key_length);
                    // Not allowed to be read so treat it as if it doesn't exist.
                    if (!EdgeFunctionHeaders_1.default.is_allowed_read_header_name(key)) {
                        return WasmProgram_1.wasm_status.not_found;
                    }
                    this.funDebug(`hostcall_resp_check_header() ${id}, '${key}'`);
                    return response.headers.check(key) ? WasmProgram_1.wasm_status.ok : WasmProgram_1.wasm_status.not_found;
                },
                // Get the response body
                hostcall_resp_get_body: (id, data_offset, len_offset) => {
                    const response = getResponse(id);
                    if (response instanceof WasmProgram_1.WasmError) {
                        return handleWasmError(response);
                    }
                    this.funDebug('hostcall_resp_get_body()', id, response.body);
                    return this.copyDataToGuestMemory(response.body || buffer_1.Buffer.alloc(0), data_offset, len_offset);
                },
                // Write message to debug stream.
                hostcall_debug: (msg_offset, msg_length) => {
                    const memory = this.getGuestMemory();
                    const msg = this.getStringFromGuestMemory(memory, msg_offset, msg_length);
                    this.funDebug(msg);
                    return WasmProgram_1.wasm_status.ok;
                },
                // Get the response error message
                hostcall_resp_get_error_code_message: (error_code, message_offset, len_offset) => {
                    let errorMessage = getFetchResponseErrorFriendlyMessage(error_code);
                    if (errorMessage === undefined) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Invalid response error code provided: ${error_code}`,
                        });
                    }
                    this.funDebug('hostcall_resp_get_error_code_message()', error_code, errorMessage);
                    return this.copyDataToGuestMemory(new TextEncoder().encode(errorMessage), message_offset, len_offset);
                },
                hostcall_metrics_start_timer: (index) => {
                    this.funDebug('hostcall_metrics_start_timer()', index);
                    if (!this.metrics.isValidIndex(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Metric index ${index} must be betwen 0 and 9`,
                        });
                    }
                    if (!this.metrics.startTimer(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Timer for metric index ${index} is already in use.`,
                        });
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_metrics_stop_timer: (index) => {
                    this.funDebug('hostcall_metrics_stop_timer()', index);
                    if (!this.metrics.isValidIndex(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Metric index ${index} must be betwen 0 and 9`,
                        });
                    }
                    if (!this.metrics.stopTimer(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Timer for metric index ${index} was not in use.`,
                        });
                    }
                    return WasmProgram_1.wasm_status.ok;
                },
                hostcall_metrics_add: (index, value) => {
                    this.funDebug('hostcall_metrics_add()', index, value);
                    if (!this.metrics.isValidIndex(index)) {
                        return handleWasmError({
                            status: WasmProgram_1.wasm_status.invalid_argument,
                            message: `Invalid metric index ${index}`,
                        });
                    }
                    this.metrics.add(index, value);
                    return WasmProgram_1.wasm_status.ok;
                },
            },
            wasi_snapshot_preview1: {
                fd_write: (fd, iovs_offset, iovs_length, bw_offset) => {
                    var _a, _b;
                    const STDOUT_FD = 1;
                    const STDERR_FD = 2;
                    // Only accept writes to stdout/stderr
                    if (fd != STDOUT_FD && fd != STDERR_FD) {
                        throw new WebAssembly.RuntimeError('Write not allowed');
                    }
                    const memory = this.getGuestMemory();
                    let bytesWritten = 0;
                    // Write all the buffers as they were given to us.
                    for (let i = 0; i < iovs_length; i++) {
                        const iov_base = memory.getUint32(iovs_offset + WasmProgram_1.SIZEOF_wasi_iovec_t * i);
                        const iov_len = memory.getUint32(iovs_offset + WasmProgram_1.SIZEOF_wasi_iovec_t * i + Uint32Array.BYTES_PER_ELEMENT);
                        const iovs = buffer_1.Buffer.from(memory.slice(iov_base, iov_base + iov_len));
                        switch (fd) {
                            case STDOUT_FD: {
                                let bytes_remaining = MAX_OUT_BYTES - this.out_written_bytes;
                                if (bytes_remaining > 0) {
                                    if (iov_len + overflow_message.length >= bytes_remaining) {
                                        this.out_written_bytes += bytes_remaining;
                                        this.parent.writeToStdout(iovs.slice(0, bytes_remaining));
                                        this.parent.writeToStdout(buffer_1.Buffer.from(overflow_message));
                                        this.parent.writeToStdout(iovs.slice(bytes_remaining));
                                    }
                                    else {
                                        this.out_written_bytes += iov_len;
                                        this.parent.writeToStdout(iovs);
                                    }
                                }
                                if (typeof window === undefined && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.LOG_LEVEL) === 'trace') {
                                    process.stdout.write(iovs);
                                }
                                break;
                            }
                            case STDERR_FD: {
                                let bytes_remaining = MAX_OUT_BYTES - this.out_written_bytes;
                                if (bytes_remaining > 0) {
                                    if (iov_len + overflow_message.length >= bytes_remaining) {
                                        this.out_written_bytes += bytes_remaining;
                                        this.parent.writeToStderr(iovs.slice(0, bytes_remaining));
                                        this.parent.writeToStderr(buffer_1.Buffer.from(overflow_message));
                                        this.parent.writeToStderr(iovs.slice(bytes_remaining));
                                    }
                                    else {
                                        this.out_written_bytes += iov_len;
                                        this.parent.writeToStderr(iovs);
                                    }
                                }
                                if (typeof window === undefined && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.LOG_LEVEL) === 'trace') {
                                    process.stderr.write(iovs);
                                }
                                break;
                            }
                            default:
                                throw new WebAssembly.RuntimeError('Write not allowed');
                        }
                        bytesWritten += iov_len;
                    }
                    memory.setUint32(bw_offset, bytesWritten);
                    return 0;
                },
                environ_get: (...args) => {
                    this.funDebug('environ_get');
                    throw new WebAssembly.RuntimeError('TODO: translate into QuickJS error');
                },
                environ_sizes_get: (environCountPtr, environBufSizePtr) => {
                    const memory = this.getGuestMemory();
                    // environ_sizes_get is supposed to write the number of arguments but we don't have any arguments.
                    memory.setUint32(environCountPtr, 0);
                    memory.setUint32(environBufSizePtr, 0);
                },
                clock_time_get: (_clockId, _precision, tsOffset) => {
                    const memory = this.getGuestMemory();
                    memory.setBigUint64(tsOffset, startTimeNs);
                },
                fd_close: (...args) => {
                    this.funDebug('TODO: fd_close');
                    throw new WebAssembly.RuntimeError('TODO: translate into QuickJS error');
                },
                fd_fdstat_get: (...args) => {
                    // this.funDebug('TODO: fd_fdstat_get')
                    // throw new WebAssembly.RuntimeError('TODO: translate into QuickJS error')
                },
                fd_seek: (...args) => {
                    this.funDebug('TODO: fd_seek');
                    throw new WebAssembly.RuntimeError('TODO: translate into QuickJS error');
                },
                proc_exit1: (...args) => {
                    this.funDebug('TODO: proc_exit1');
                    throw new WebAssembly.RuntimeError('TODO: translate into QuickJS error');
                },
                proc_exit: (...args) => {
                    this.funDebug('TODO: proc_exit', args);
                    throw new WebAssembly.RuntimeError('TODO: translate into QuickJS error');
                },
                random_get: (...args) => {
                    this.funDebug('TODO: random_get', args);
                    // throw new WebAssembly.RuntimeError('TODO: translate into QuickJS error')
                },
            },
        };
    }
}
exports.default = EdgeFunction;
