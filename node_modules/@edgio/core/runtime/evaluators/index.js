"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleEvaluator = exports.toUppercaseEvaluator = exports.toLowercaseEvaluator = exports.findReplaceEvaluator = exports.substringEvaluator = exports.removeTrailingEvaluator = exports.removeLeadingEvaluator = exports.assignOnNotNullEvaluator = exports.assignOnNullEvaluator = void 0;
const Evaluator_1 = require("./Evaluator");
const toEdgeRegex_1 = require("../../utils/toEdgeRegex");
const regexUtils_1 = require("../../utils/regexUtils");
/**
 * If the value of varname is unset or empty string,
 * string is assigned to varname. The value of varname is then substituted.
 * If the colon is omitted, the operator tests only for existence of varname.
 *
 * Format: %{varname:=stringToAssign} OR %{varname=stringToAssign}
 * Example:
 * Values: { emptyVarname: "" }
 * Expression: "%{varname:=newValue}" => "newValue"
 * Expression: "%{emptyVarname:=newValue}" => "newValue"
 * Expression: "%{varname=newValue}" => "newValue"
 * Expression: "%{emptyVarname=newValue}" => ""
 */
exports.assignOnNullEvaluator = new Evaluator_1.Evaluator(params => {
    const [lowerCaseName, colon, newValue] = params.matched;
    // test for unset varname and non-empty string when format with colon is used
    if (lowerCaseName in params.values && (!colon || params.values[lowerCaseName].length > 0))
        return params.values[lowerCaseName];
    params.values[lowerCaseName] = newValue;
    return newValue;
}, /^([A-Za-z0-9_-]+)(:?)=(.*)$/);
/**
 * If the value of varname is unset or empty string, nothing is substituted,
 * otherwise string is assigned to varname.
 * If the colon is omitted, the operator tests only for existence of varname.
 *
 * Format: %{varname:+stringToAssign} OR %{varname+stringToAssign}
 * Example:
 * Values: { varname: "something", emptyVarname: "" }
 * Expression: "%{varname:+newValue}" => "newValue"
 * Expression: "%{emptyVarname:+newValue}" => ""
 * Expression: "%{varname+newValue}" => "newValue"
 * Expression: "%{emptyVarname+newValue}" => "newValue"
 */
exports.assignOnNotNullEvaluator = new Evaluator_1.Evaluator(params => {
    const [lowerCaseName, colon, newValue] = params.matched;
    // test for not unset varname or empty string when format with colon is used
    if (!(lowerCaseName in params.values) || (colon && params.values[lowerCaseName].length === 0))
        return '';
    params.values[lowerCaseName] = newValue;
    return newValue;
}, /^([A-Za-z0-9_-]+)(:?)\+(.*)$/);
/**
 * If the pattern matches the beginning of the value of varname, then
 * the result is the value of varname with the matching pattern deleted.
 *
 * Format: %{varname#pattern}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname#thing}" => "some"
 */
exports.removeLeadingEvaluator = new Evaluator_1.Evaluator(params => {
    const [lowerCaseName, pattern] = params.matched;
    if (!(lowerCaseName in params.values))
        return undefined;
    return params.values[lowerCaseName].replace(new RegExp(`^${pattern}`), '');
}, /^([A-Za-z0-9_-]+)#(.+)$/);
/**
 * If the pattern matches a trailing portion of the value of varname, then
 * the result is the the value of varname with the matching pattern deleted.
 *
 * Format: %{varname%pattern}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname%some}" => "thing"
 */
exports.removeTrailingEvaluator = new Evaluator_1.Evaluator(params => {
    const [lowerCaseName, pattern] = params.matched;
    if (!(lowerCaseName in params.values))
        return undefined;
    return params.values[lowerCaseName].replace(new RegExp(`${pattern}$`), '');
}, /^([A-Za-z0-9_-]+)%(.+)$/);
/**
 * Expands to up to length characters of varname starting at the character
 * specified by offset. If length is omitted, expands to the substring of varname
 * starting at the character specified by offset. length and offset are numberic constants.
 *
 * If offset is a number less than zero, the value is used as an offset from
 * the end of the value of varname. If length evaluates to a number less than zero,
 * it is interpreted as an offset from the end of the value of varname rather than a
 * number of characters, and the expansion is the characters between the two offsets.
 *
 * Format: %{varname:offset:length}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname:1:4}" => "omet"
 */
exports.substringEvaluator = new Evaluator_1.Evaluator(params => {
    const [lowerCaseName, offsetString, lengthString] = params.matched;
    if (!(lowerCaseName in params.values))
        return undefined;
    const valueLength = params.values[lowerCaseName].length;
    const offset = parseInt(offsetString);
    // Use length of the value if length param is not specified
    const length = !lengthString ? valueLength : parseInt(lengthString);
    // When offset is negative number but length positive, transform offset to positive index from the end of string
    const startIndex = offset < 0 && length >= 0 ? valueLength + offset : offset;
    // When startIndex is negative, assume that the provided length is index
    const endIndex = (startIndex < 0 ? 0 : startIndex) + length;
    return params.values[lowerCaseName].slice(startIndex, endIndex);
}, /^([A-Za-z0-9_-]+):(-?[0-9]+):(-?[0-9]*)$/);
/**
 * Find and replace values using regular expressions. The match of pattern against its value is replaced with string.
 * If pattern begins with '/', all matches of pattern are replaced with string otherwise only the first match is replaced.
 * If pattern begins with '/=', only replaceString is returned with substituted matched values.
 * Doesn't support L and U flags ($U1, $L1) in regex substitution.
 *
 * Format: %{varname/searchPattern/replaceString} OR %{varname//searchPattern/replaceString} OR %{varname/=searchPattern/replaceString}
 * Example:
 * Values: { varname: "something something" }
 * Expression: "%{varname/meth/NEW}" => "soNEWing something"
 * Expression: "%{varname//meth/NEW}" => "soNEWing soNEWing"
 * Expression: "%{varname/=^(.+)thing some(.+)$/$2 $1}" => "thing some"
 *
 * TODO: Add support for L and U flags in regex substitution â†“
 * Expression: "%{varname/^(.+)$/$U1}" => "SOMETHING SOMETHING"
 * Expression: "%{varname/=^(.+)thing some(.+)$/$U2 $L1}" => "THING some"
 */
exports.findReplaceEvaluator = new Evaluator_1.Evaluator(params => {
    const [lowerCaseName, delimiter, searchValue, replaceValue] = params.matched;
    if (!(lowerCaseName in params.values))
        return undefined;
    // construct regex from edge regex to preserve /i flag
    const patternRegex = (0, toEdgeRegex_1.fromEdgeRegex)(searchValue);
    // performs only substitution without replacement in source string
    if (delimiter === '/=')
        return (0, regexUtils_1.substituteParams)(patternRegex, params.values[lowerCaseName], replaceValue);
    return params.values[lowerCaseName].replace(new RegExp(patternRegex.source, 
    // add global flag based on used format
    `${patternRegex.flags}${delimiter === '//' ? 'g' : ''}`), replaceValue);
}, /^([A-Za-z0-9_-]+)(\/\/?=?)(.+)\/(.*)$/);
/**
 * Converts matching group of variable's value to lowercase.
 * If ',' format is used, only the first match is converted.
 * All matches are converted when ',,' format is used.
 * If no pattern is provided the whole string is converted to lowercase.
 *
 * Format: %{varname,pattern} OR %{varname,,pattern}
 * Example:
 * Values: { varname: "ThIs Is A mIx Of LoWer-Upper cAse." }
 * Expression: "%{varname,}" => "this is a mix of lower-upper case."
 * Expression: "%{varname,is}" => "This Is A mIx Of LoWer-Upper cAse."
 * Expression: "%{varname,,is}" => "This is A mIx Of LoWer-Upper cAse."
 */
exports.toLowercaseEvaluator = new Evaluator_1.Evaluator(params => {
    const [lowerCaseName, delimiter, pattern] = params.matched;
    if (!(lowerCaseName in params.values))
        return undefined;
    const patternRegex = new RegExp(`(${!pattern ? '(.*)' : pattern})`, `i${delimiter === ',,' ? 'g' : ''}`);
    return params.values[lowerCaseName].replace(patternRegex, match => match.toLowerCase());
}, /^([A-Za-z0-9_-]+)(,,?)(.*)$/);
/**
 * Converts matching group of variable's value to uppercase.
 * If '^' format is used, only the first match is converted.
 * All matches are converted when '^^' format is used.
 * If no pattern is provided the whole string is converted to uppercase.
 *
 * Format: %{varname^pattern} OR %{varname^^pattern}
 * Example:
 * Values: { varname: "ThIs Is A mIx Of LoWer-Upper cAse." }
 * Expression: "%{varname^}" => "THIS IS A MIX OF LOWER-UPPER CASE."
 * Expression: "%{varname^is}" => "ThIS Is A mIx Of LoWer-Upper cAse."
 * Expression: "%{varname^^is}" => "ThIS IS A mIx Of LoWer-Upper cAse."
 */
exports.toUppercaseEvaluator = new Evaluator_1.Evaluator(params => {
    const [lowerCaseName, delimiter, pattern] = params.matched;
    if (!(lowerCaseName in params.values))
        return undefined;
    const patternRegex = new RegExp(`(${!pattern ? '(.*)' : pattern})`, `i${delimiter === '^^' ? 'g' : ''}`);
    return params.values[lowerCaseName].replace(patternRegex, match => match.toUpperCase());
}, /^([A-Za-z0-9_-]+)(\^\^?)(.*)$/);
/**
 * Performs simple interpolation when variables are replaced by values.
 * This Evaluator should be placed to the end of EvaluatorGroup
 * because it returns empty string when certain variables starting with http|resp|arg|cookie don't exist.
 *
 * Format: %{varname}
 * Example:
 * Values: { varname: "something" }
 * Expression: "%{varname}" => "something"
 * Expression: "%{arg_undefined_varname}" => ""
 * Expression: "%{undefined_varname}" => undefined => "%{undefined_varname}"
 */
exports.simpleEvaluator = new Evaluator_1.Evaluator(params => {
    const [lowerCaseName] = params.matched;
    if (lowerCaseName in params.values)
        return params.values[lowerCaseName];
    return /(http|resp|arg|cookie)_[A-Za-z0-9_-]+/g.test(lowerCaseName) ? '' : undefined;
}, /(.+)/);
