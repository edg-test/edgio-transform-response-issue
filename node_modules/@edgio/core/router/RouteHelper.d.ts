import { Features, HttpStatusCode } from '../types';
import CorsOptions from './CorsOptions';
import CookieOptions from './CookieOptions';
import RouteCriteria from './RouteCriteria';
import { HTTP_METHODS } from '../constants';
import { CacheOptions } from './CacheOptions';
import { RedirectOptions } from './RedirectOptions';
import { ServeStaticOptions } from './ServeStaticOptions';
import Router, { ComputeFn } from './Router';
import { ProxyOptions } from './ProxyOptions';
import { ExactPath } from '../router/exact';
/**
 * A function used to configure a route through the `RouteHelper`.
 */
export type FeatureCreator = (helper: RouteHelper) => void;
/**
 * Enumeration (string literal) of all HTTP methods supported by Edgio.
 */
export type HTTPMethod = keyof typeof HTTP_METHODS;
/**
 * RouteHelper makes it easy to implement common request handling patterns and provides backwards compatibility with Layer0's
 * [ResponseWriter](https://docs.layer0.co/docs/api/core/classes/_router_responsewriter_.responsewriter.html) class.
 *
 * When a function is passed to the second argument of a route, that function is provided with an instance of RouteHelper as the sole argument.
 * For example:
 *
 * **Example**
 *
 * ```js
 *  import { Router } = from '@edgio/core/router'
 *
 *  export default new Router()
 *    .get('/favicon.ico', ({ serveStatic }) => { // the parameter provided here is an instance of RouteHelper
 *      serveStatic('images/favicon.ico')
 *    })
 * ```
 */
export default class RouteHelper {
    private readonly routeCriteria;
    private paramsExtractor;
    private features;
    private readonly router;
    /**
     * @private
     * @param criteria
     * @param router
     */
    constructor(criteria: RouteCriteria, router: Router);
    /**
     * Creates a Features instance by running the provided callback.
     * @private
     * @param creator
     * @returns
     */
    evaluate(creator: FeatureCreator): Features;
    /**
     * Serves a service worker with proper edge and browser cache headers.
     * @param filePath The path to the service worker relative to the root directory of your app
     *
     * **Example**
     *
     * ```js
     *  import { Router } = from '@edgio/core/router'
     *
     *  export default new Router()
     *    .get('/service-worker.js', ({ serviceWorker }) => {
     *      serviceWorker('dist/service-worker.js')
     *    })
     * ```
     */
    serviceWorker: (filePath?: string) => void;
    /**
     * Sets the caching behavior for both browser and edge.
     *
     * **Example**
     *
     * ```
     *  import { Router } = from '@edgio/core/router'
     *
     *  export default new Router()
     *    .get('/p/:productId', ({ cache, proxy }) => {
     *      cache({
     *        browser: {
     *          maxAgeSeconds: 0,
     *          serviceWorkerSeconds: 60 * 60, // 1 hour
     *        },
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24, // 24 hours
     *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
     *        }
     *      })
     *      proxy('origin')
     *    })
     * ```
     *
     * The `cache()` method can be called in the same route where the response is sent, or any prior route.  For example,
     * with Next.js, it is common to use the next plugin to automatically inherit page routes based on Next.js conventions,
     * and use Layer0 router simply to add caching:
     *
     * ```
     *  import { Router } = from '@edgio/core/router'
     *  import { nextRoutes } from '@edgio/next'
     *
     *  const { nextMiddleware, renderNext } = createNextPlugin()
     *
     *  export default new Router()
     *    .get('/p/:productId', ({ cache, proxy }) => {
     *      cache({
     *        browser: {
     *          maxAgeSeconds: 0,
     *          serviceWorkerSeconds: 60 * 60, // 1 hour
     *        },
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24, // 24 hours
     *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
     *        }
     *      })
     *      proxy('origin')
     *    })
     *    .use(nextRoutes)
     * ```
     */
    cache: (options: CacheOptions) => void;
    /**
     * Responds with a static asset from the specified path.
     *
     * **Example**
     *
     * ```js
     * serveStatic('path/to/asset/from/app/root')
     * ```
     *
     * You can also use variables in the asset path.  For example, to return files under the `assets` directory
     * when the url starts with `/static`:
     *
     * ```
     *  new Router()
     *    .get('/static/:path*', ({ serveStatic }) => {
     *      serveStatic('assets/:path*')
     *    })
     * ```
     *
     * The substitution group params can be used in the asset path when path criteria is Regular Expression.
     * The same functionality can be achieved using the code below.
     *
     * ```
     *  new Router()
     *    .get(/\/static\/(.*)/, ({ serveStatic }) => {
     *      serveStatic('assets/$1')
     *    })
     * ```
     * @param path The relative path to the asset from the app's root directory. You can reference path variables using `:variable`.
     * @param options The different options to serving static assets including fallback to compute
     * @returns A promise the resolves once the asset has been fetched from storage.
     */
    serveStatic: (path: string, options?: ServeStaticOptions) => void;
    /**
     * Renders a result in Edgio's serverless cloud using your application. Use this method
     * to respond with an SSR or API result from your application.
     */
    renderWithApp: () => void;
    /**
     * Execute the provided callback function in the cloud. The callback is passed the request and the response.
     *
     * Use this method when you need to compute a response in the cloud rather than at the edge or at build time. A common example
     * is when the response must be computed based on request parameters, headers, or cookies.
     *
     * A common example is to look up the destination for a redirect from an external API:
     *
     * ```js
     *  new Router()
     *    .get('/products/:id', ({ redirect, compute }) => {
     *      compute(async (request, response) => {
     *        const destination = await getDestinationFromAPI(request.params.id)
     *        redirect(destination)
     *      })
     *    })
     * ```
     *
     * This method can be combined with `cache` to compute responses in the cloud and cache them at edge:
     *
     * ```js
     *  new Router()
     *    .get('/products/:id', ({ cache, redirect, compute }) => {
     *      cache({
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24,
     *          staleWhileRevalidateSeconds: 60 * 60,
     *        }
     *      })
     *      compute(async (request, response) => {
     *        const destination = await getDestinationFromAPI(request.params.id)
     *        redirect(destination)
     *      })
     *    })
     * ```
     *
     * Note: when calling `compute` in combination with `serveStatic`, the result of the `serveStatic` must be
     * awaited in order to get the result from `serveStatic`, otherwise only reslut of the `compute` method
     * will be returned.
     *
     * ```js
     * new Router()
     *   .get('/products/:id', ({ redirect, compute }) => {
     *      compute(async (request, response) => {
     *        const destination = await getDestinationFromAPI(request.params.id)
     *        await serveStatic(destination)
     *      })
     *    })
     * ```
     *
     * Note: Extracted params from express-style criteria are available as object under req.params.
     * When regular expression is used as path criteria, the matched group params are available as array under req.params.$.
     * Example: $1 => req.params.$[1]
     *
     * @param fn A function to run in the cloud to compute the response
     */
    compute: (fn: ComputeFn) => void;
    /**
     * Relays the request to the specified origin.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path/with/:variable', ({ proxy }) => {
     *      proxy('legacy', { path: '/some/other/path/with/:variable' })
     *    })
     * ```
     *
     * In this example, we relay the request to the "legacy" origin. In this case, `edgio.config.js` must
     * contain a definition for the `legacy` origin.  For example:
     *
     * ```
     *  // edgio.config.js
     *
     *  module.exports = {
     *    routes: "./routes.js",
     *    ...
     *    origins: [
     *       {
     *         name: 'legacy',
     *         balancer: 'round_robin',
     *         hosts: [{ location: 'legacy.domain.com' }],
     *       },
     *     ],
     *  }
     * ```
     *
     * @param backend The name of one of the origins in your `edgio.config.js` file.
     * @param options
     * @returns A promise the resolves once the response has been fetched from the upstream site.
     */
    proxy: (backend: string, options?: ProxyOptions) => void;
    /**
     * Adds or replaces existing response header
     * immediately before delivering the response downstream.
     * New value can be appended to the end of existing value by prepending a `+` symbol to the header name.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setResponseHeader, proxy }) => {
     *      proxy('origin')
     *      setResponseHeader('new-header', 'some-value')
     *      setResponseHeader('+existing-header', 'other-value')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param value The value to set
     */
    setResponseHeader: (name: string, value: string) => void;
    /**
     * Adds new response header without replacing existing headers with the same name
     * before delivering the response downstream.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ addResponseHeader, proxy }) => {
     *      proxy('origin')
     *      addResponseHeader('some-header', 'some-value')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param value The value to set
     */
    addResponseHeader: (name: string, value: string) => void;
    /**
     * Alters a response header immediately before delivering the response downstream.
     * Use this method to derive the new header value from the existing one.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateResponseHeader, proxy }) => {
     *      proxy('origin')
     *      updateResponseHeader('some-header', /some-.*-part/gi, 'some-replacement')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateResponseHeader: (name: string, match: RegExp, replace: string) => void;
    /**
     * Removes a response header immediately before delivering the response downstream.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeResponseHeader, proxy }) => {
     *      proxy('origin')
     *      removeResponseHeader('some-header')
     *    })
     * ```
     * @param name The case-insensitive name of the response header
     */
    removeResponseHeader: (name: string) => void;
    /**
     * Removes a header from the response provided by an origin server.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeUpstreamResponseHeader, proxy }) => {
     *      proxy('origin')
     *      removeUpstreamResponseHeader('some-header')
     *    })
     * ```
     * @param name The case-insensitive name of the response header
     */
    removeUpstreamResponseHeader: (name: string) => void;
    /**
     * Adds or replaces a request header.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setRequestHeader, proxy }) => {
     *      setRequestHeader('some-header', 'some-value')
     *      proxy('origin')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the request header
     * @param value The value to set
     */
    setRequestHeader: (name: string, value: string) => void;
    /**
     * Alters a request header. Use this method to derive the new header value from the existing one.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateRequestHeader, proxy }) => {
     *      updateRequestHeader('some-header', /some-.*-part/gi, 'some-replacement')
     *      proxy('origin')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the request header
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateRequestHeader: (name: string, match: RegExp, replace: string) => void;
    /**
     * Adds or replaces a response body. It optionally sets response code or message.
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setResponseBody }) => {
     *      setResponseBody('<html><body>Hello World!</body></html>', 200, 'OK')
     *    })
     * ```
     *
     * @param body The response body.
     * @param code The response code.
     * @param done Indicates that this is last feature
     */
    setResponseBody: (body: string, code?: HttpStatusCode, done?: boolean) => void;
    /**
     * Adds or replaces a response code.
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setResponseCode, proxy }) => {
     *      setResponseCode(200)
     *      proxy('origin')
     *    })
     * ```
     *
     * @param code The response code.
     */
    setResponseCode: (code: HttpStatusCode) => void;
    /**
     * Sends the necessary response headers to allow CORS.
     *
     * **Example**
     *
     * ```js
     *  new Router()
     *    .match('/api/:path*', ({ allowCors }) => {
     *      allowCors({
     *        origin: '*', // this is the default
     *        methods: ['get', 'post'],
     *        headers: ['x-some-header'],
     *        maxAge: 60 * 60, // one hour
     *        credentials: true
     *      })
     *    })
     * ```
     *
     * @param config
     */
    allowCors: (config?: CorsOptions) => void;
    /**
     * Adds a path_rewrite feature using path-to-regexp syntax for the source and destination
     * @param source
     * @param destination
     * @param skipOptionalQuery
     * @private
     */
    rewritePath: (source: string | RegExp | ExactPath | undefined, destination: string, skipOptionalQuery?: boolean) => void;
    /**
     * Forwards the request to the serverless origin
     * @param hint
     * @param fn
     */
    private sendToServerless;
    /**
     * Rewrites the request path.
     *
     * Example:
     *
     * ```js
     *  router.get('/products/:id', ({ updatePath }) => {
     *    updatePath('/p/:id')
     *  })
     * ```
     *
     * The substitution group params can be used in the asset path when path criteria is Regular Expression.
     * The same functionality can be achieved using the code below.
     *
     * ```js
     *  new Router()
     *    .get(/\/products\/(.+)/, ({ updatePath }) => {
     *      updatePath('/p/$1')
     *    })
     * ```
     *
     * @param destination a new route path, which can include params captured from the original path
     */
    updatePath: (destination: string) => void;
    /**
     * Sends string content back to client. If content is a string, the response will be sent
     * directly from the edge. If it is a function, the request will be computed by a JavaScript worker.
     * StatusCode defaults to 200. On error routes we send the status code
     * as null, since we need to preserve the status code of the failed request unless it is provided.
     * @param content The content to send to the browser
     * @param statusCode The HTTP status code.
     * @param statusMessage The HTTP status message
     */
    send: (content: string | (() => string), statusCode: HttpStatusCode | undefined) => void;
    /**
     * Removes a request header.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', async ({ removeRequestHeader, proxy }) => {
     *      removeRequestHeader('some-header')
     *      proxy('origin')
     *    })
     * ```
     * @param name The case-insensitive name of the request header
     */
    removeRequestHeader: (name: string) => void;
    /**
     * Serves an HTML app shell from a static file.
     * @param indexHtmlPath The path to the app shell html file
     *
     * **Example**
     *
     * ```js
     *  new Router()
     *    .fallback(({ appShell }) => {
     *      appShell('dist/index.html')
     *    })
     * ```
     */
    appShell: (indexHtmlPath: string) => void;
    /**
     * Redirects the browser to a new location.
     * Query params from the original request are added to the redirect URL
     *
     * **Examples**
     *
     * ```
     *  new Router()
     *    .get('/p/:productId', ({ redirect }) => {
     *      return redirect('/products/:productId', { statusCode: 301 })
     *    })
     *.
     *  // The substitution group params can be used in the redirect location when path criteria is Regular Expression.
     *  new Router()
     *    .get(/\/p\/(.+)/, ({ redirect }) => {
     *      return redirect('/products/$1', { statusCode: 301 })
     *    })
     *
     *  // Extract id from route and apply as query string
     *  new Router()
     *    .get('/p/:productId', ({ redirect }) => {
     *      return redirect('/product', { query: { id: ':productId' }})
     *    })
     *
     *  new Router()
     *  .get(/\/p\/(\d+)\/?/, ({ redirect }) => {
     *      return redirect('/product', { query: { id: '$1' }})
     *    })
     *
     *  // Extract id from query string and apply to route
     *  new Router()
     *    .get({ path: '/p', query: { id: ':id' } }, ({ redirect }) => {
     *      return redirect('/product/:id')
     *    })
     * ```
     *
     * @param to The URL to which the browser will be redirected.
     * @param options
     * @param options.statusCode The HTTP status to return. Defaults to 302
     * @param options.query Key-value object of query strings to be added to the redirect url
     */
    redirect: (to: string, options?: RedirectOptions) => void;
    /**
     * Adds a `set-cookie` header to the response.
     * This does not replace any cookies with the same name - for that you should use `updateResponseCookie`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ addResponseCookie, proxy }) => {
     *      proxy('origin')
     *      addResponseCookie('my-cookie', 'my-cookie-value', { domain: 'test.com' })
     *    })
     * ```
     *
     * @param name Name of the cookie to add.
     * @param value Value to set
     * @param options Optional options to add to cookie
     */
    addResponseCookie: (name: string, value: string, options?: CookieOptions) => void;
    /**
     * Allows to change the origin that the request is proxied to.
     * This is useful when you want to proxy to a different origin based on the matched rule.
     * The origin set by the latest matched rule will be used.
     *
     * This method doesn't affect the proxy method.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/:path*', ({ setOrigin }) => {
     *      setOrigin('fallback_origin')
     *    })
     *    .get('/products/1', ({ setOrigin }) => {
     *      setOrigin('web_origin')
     *    })
     * ```
     *
     * @param name the origin name
     */
    setOrigin: (name: string) => void;
    /**
     * Allows to set a comment feature on the rule, which will be displayed in the dashboard.
     * The comment message supports markdown.
     * @param message
     */
    setComment: (message: string, append?: boolean) => void;
}
