"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const path_1 = require("./path");
const origins_1 = require("../origins");
const RouteCriteria_1 = require("./RouteCriteria");
const constants_2 = require("../constants");
const RedirectOptions_1 = require("./RedirectOptions");
const OriginFetcher_1 = __importDefault(require("../runtime/OriginFetcher"));
const isEmpty_1 = __importDefault(require("../utils/isEmpty"));
const bindParams_1 = __importDefault(require("../utils/bindParams"));
const ParamsExtractor_1 = __importDefault(require("./ParamsExtractor"));
const qs_1 = __importDefault(require("qs"));
const toEdgeRegex_1 = __importDefault(require("../utils/toEdgeRegex"));
const cookieUtils_1 = require("../utils/cookieUtils");
const exact_1 = require("../router/exact");
const toTimeInterval_1 = require("./converters/toTimeInterval");
/**
 * RouteHelper makes it easy to implement common request handling patterns and provides backwards compatibility with Layer0's
 * [ResponseWriter](https://docs.layer0.co/docs/api/core/classes/_router_responsewriter_.responsewriter.html) class.
 *
 * When a function is passed to the second argument of a route, that function is provided with an instance of RouteHelper as the sole argument.
 * For example:
 *
 * **Example**
 *
 * ```js
 *  import { Router } = from '@edgio/core/router'
 *
 *  export default new Router()
 *    .get('/favicon.ico', ({ serveStatic }) => { // the parameter provided here is an instance of RouteHelper
 *      serveStatic('images/favicon.ico')
 *    })
 * ```
 */
class RouteHelper {
    /**
     * @private
     * @param criteria
     * @param router
     */
    constructor(criteria, router) {
        this.features = {};
        /**
         * Serves a service worker with proper edge and browser cache headers.
         * @param filePath The path to the service worker relative to the root directory of your app
         *
         * **Example**
         *
         * ```js
         *  import { Router } = from '@edgio/core/router'
         *
         *  export default new Router()
         *    .get('/service-worker.js', ({ serviceWorker }) => {
         *      serviceWorker('dist/service-worker.js')
         *    })
         * ```
         */
        this.serviceWorker = (filePath) => {
            this.cache({ edge: { maxAgeSeconds: constants_1.FAR_FUTURE_TTL }, browser: false });
            if (filePath) {
                this.serveStatic(filePath);
            }
            else {
                this.setOrigin(origins_1.STATIC_ORIGIN_NAME);
                this.rewritePath(undefined, `${(0, origins_1.getPathPrefix)(origins_1.STATIC_ORIGIN_NAME)}/service-worker.js`);
            }
        };
        /**
         * Sets the caching behavior for both browser and edge.
         *
         * **Example**
         *
         * ```
         *  import { Router } = from '@edgio/core/router'
         *
         *  export default new Router()
         *    .get('/p/:productId', ({ cache, proxy }) => {
         *      cache({
         *        browser: {
         *          maxAgeSeconds: 0,
         *          serviceWorkerSeconds: 60 * 60, // 1 hour
         *        },
         *        edge: {
         *          maxAgeSeconds: 60 * 60 * 24, // 24 hours
         *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
         *        }
         *      })
         *      proxy('origin')
         *    })
         * ```
         *
         * The `cache()` method can be called in the same route where the response is sent, or any prior route.  For example,
         * with Next.js, it is common to use the next plugin to automatically inherit page routes based on Next.js conventions,
         * and use Layer0 router simply to add caching:
         *
         * ```
         *  import { Router } = from '@edgio/core/router'
         *  import { nextRoutes } from '@edgio/next'
         *
         *  const { nextMiddleware, renderNext } = createNextPlugin()
         *
         *  export default new Router()
         *    .get('/p/:productId', ({ cache, proxy }) => {
         *      cache({
         *        browser: {
         *          maxAgeSeconds: 0,
         *          serviceWorkerSeconds: 60 * 60, // 1 hour
         *        },
         *        edge: {
         *          maxAgeSeconds: 60 * 60 * 24, // 24 hours
         *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
         *        }
         *      })
         *      proxy('origin')
         *    })
         *    .use(nextRoutes)
         * ```
         */
        this.cache = (options) => {
            this.features.caching = this.features.caching || {};
            const { caching } = this.features;
            if (options.edge) {
                if (options.edge.maxAgeSeconds) {
                    caching.max_age = (0, toTimeInterval_1.toTimeInterval)(options.edge.maxAgeSeconds);
                }
                if (options.edge.staleWhileRevalidateSeconds) {
                    caching.stale_while_revalidate = (0, toTimeInterval_1.toTimeInterval)(options.edge.staleWhileRevalidateSeconds);
                }
                if (options.edge.forcePrivateCaching) {
                    caching.ignore_origin_no_cache = [200];
                }
            }
            else if (options.edge === false) {
                caching.bypass_cache = true;
            }
            if (options && options.cacheableStatusCodes) {
                caching.cacheable_status_codes = options.cacheableStatusCodes;
            }
            if (options && options.enableCachingMethods) {
                caching.enable_caching_for_methods = options.enableCachingMethods;
            }
            if (options.browser) {
                if (options.browser.serviceWorkerSeconds == null && options.browser.maxAgeSeconds == null) {
                    throw new Error('The browser cache setting should specify serviceWorkerSeconds or maxAgeSeconds.');
                }
                if (options.browser.serviceWorkerSeconds) {
                    // We still need to set the header for the service worker to work
                    // because we are checking it in @edgio/prefetch/sw/PrefetchPlugin.
                    // This is the way how we can store the SW TTL together with response in cache
                    // and override it with options from prefetch() function.
                    // TODO: remove this when we will have a better way to store modified SW TTL in cache by PrefetchPlugin
                    this.setResponseHeader(constants_2.HTTP_HEADERS.xSwCacheControl, `max-age=${options.browser.serviceWorkerSeconds}`);
                    caching.service_worker_max_age = (0, toTimeInterval_1.toTimeInterval)(options.browser.serviceWorkerSeconds);
                }
                if (options.browser.maxAgeSeconds === 0) {
                    caching.bypass_client_cache = true;
                }
                else if (options.browser.maxAgeSeconds) {
                    caching.client_max_age = (0, toTimeInterval_1.toTimeInterval)(options.browser.maxAgeSeconds);
                }
            }
            else if (options.browser === false) {
                caching.bypass_client_cache = true;
            }
            if (options.key) {
                options.key.applyCaching(this.features);
            }
        };
        /**
         * Responds with a static asset from the specified path.
         *
         * **Example**
         *
         * ```js
         * serveStatic('path/to/asset/from/app/root')
         * ```
         *
         * You can also use variables in the asset path.  For example, to return files under the `assets` directory
         * when the url starts with `/static`:
         *
         * ```
         *  new Router()
         *    .get('/static/:path*', ({ serveStatic }) => {
         *      serveStatic('assets/:path*')
         *    })
         * ```
         *
         * The substitution group params can be used in the asset path when path criteria is Regular Expression.
         * The same functionality can be achieved using the code below.
         *
         * ```
         *  new Router()
         *    .get(/\/static\/(.*)/, ({ serveStatic }) => {
         *      serveStatic('assets/$1')
         *    })
         * ```
         * @param path The relative path to the asset from the app's root directory. You can reference path variables using `:variable`.
         * @param options The different options to serving static assets including fallback to compute
         * @returns A promise the resolves once the asset has been fetched from storage.
         */
        this.serveStatic = (path, options = {}) => {
            var _a, _b;
            const { edgeMaxAgeSeconds = constants_1.FAR_FUTURE_TTL, permanent } = options;
            /*
             * Notes:
             * - if a folder contains an 'index.html', that page is also served when requesting the parent folder route.
             *   Let's take the example of /posts/1 that will render /posts/1/index.html)
             *   They are multiple components involved in this rewrite to make it work with S3 storage:
             *
             *   1. DeploymentBuilder creates and bundles an assets-aliases.json file, that indicates that
             *     '/posts/1' should point to '/posts/1/index.html' asset file.
             *   2. layer0-subaccount-infra/components/deploy-lambda/src/deploy.js re-uploads '/posts/1/index.html'
             *     as '/posts/1' s3 key, which works because S3 is a key based storage and not a filesystem.
             *     It's a bit of a hack and takes extra space, but allows root document rendering.
             *   3. serveStatic(), both in ResponseWriter ad EdgeResponseWriter, remove any trailing slash on path
             *     so that both '/posts/1/' and '/posts/1' match the '/posts/1' S3 file
             *
             * - We did not use S3 built-in Static Website feature for multiple reasons:
             *   1. It is http only
             *   2. /build-slug/public/posts/ renders /build-slug/public/posts/index.html correctly, but /build-slug/public/posts
             *      without a trailing slash redirects to /build-slug/public/posts/.
             *      While it's easy to rewrite the path and remove trailing slashes, we actually do, it's not easy
             *      to add missing trailing slash as we don't know beforehand if the route is a directory or a file.
             *      Having a redirect on every route is not acceptable either.
             *      The Location header would also need to be rewritten to be relative to the actual website and
             *      not the bucket prefix, but that's manageable.
             *
             * - ISG/ISR:
             *   When handling a request for a static asset that is not in S3, the request follows this path:
             *
             *     Browser => Edge => S3 (requested asset, which results in a 404)
             *                Edge => Buffer Proxy => S3 (options.loadingPage, if provided) => Response returned
             *                                     => Edge => Buffer Proxy => Lambda => BehindEdgeResponseWriter => options.onNotFound => SSR (then this response is cached for the next request)
             *
             *   Note that BehindEdgeResponseWriter is the key here. It overrides serveStatic and if options.onNotFound is provided, it will always be called.
             *
             */
            this.cache({ edge: { maxAgeSeconds: edgeMaxAgeSeconds } });
            const origin = permanent ? origins_1.PERMANENT_STATIC_ORIGIN_NAME : origins_1.STATIC_ORIGIN_NAME;
            this.setOrigin(origin);
            const pathPrefix = (0, origins_1.getPathPrefix)(origin);
            path = path.startsWith('/') ? path.slice(1) : path;
            // When path is an array, we match this againts in operator
            // so we need to decide which source to use when we have multiple paths
            const source = Array.isArray(this.routeCriteria.path) || (0, RouteCriteria_1.isNegation)(this.routeCriteria.path)
                ? (_a = options.rewritePathSource) !== null && _a !== void 0 ? _a : '/:path*'
                : (_b = this.routeCriteria.path) !== null && _b !== void 0 ? _b : '/:path*';
            if (options.statusCode) {
                this.setResponseCode(options.statusCode);
            }
            // TODO remove this once edge control supports path_prefix in origins.hosts
            this.rewritePath(source, `${pathPrefix}/${path}`, true);
        };
        /**
         * Renders a result in Edgio's serverless cloud using your application. Use this method
         * to respond with an SSR or API result from your application.
         */
        this.renderWithApp = () => {
            this.sendToServerless(constants_1.EDGIO_SERVERLESS_HINTS.app);
        };
        /**
         * Execute the provided callback function in the cloud. The callback is passed the request and the response.
         *
         * Use this method when you need to compute a response in the cloud rather than at the edge or at build time. A common example
         * is when the response must be computed based on request parameters, headers, or cookies.
         *
         * A common example is to look up the destination for a redirect from an external API:
         *
         * ```js
         *  new Router()
         *    .get('/products/:id', ({ redirect, compute }) => {
         *      compute(async (request, response) => {
         *        const destination = await getDestinationFromAPI(request.params.id)
         *        redirect(destination)
         *      })
         *    })
         * ```
         *
         * This method can be combined with `cache` to compute responses in the cloud and cache them at edge:
         *
         * ```js
         *  new Router()
         *    .get('/products/:id', ({ cache, redirect, compute }) => {
         *      cache({
         *        edge: {
         *          maxAgeSeconds: 60 * 60 * 24,
         *          staleWhileRevalidateSeconds: 60 * 60,
         *        }
         *      })
         *      compute(async (request, response) => {
         *        const destination = await getDestinationFromAPI(request.params.id)
         *        redirect(destination)
         *      })
         *    })
         * ```
         *
         * Note: when calling `compute` in combination with `serveStatic`, the result of the `serveStatic` must be
         * awaited in order to get the result from `serveStatic`, otherwise only reslut of the `compute` method
         * will be returned.
         *
         * ```js
         * new Router()
         *   .get('/products/:id', ({ redirect, compute }) => {
         *      compute(async (request, response) => {
         *        const destination = await getDestinationFromAPI(request.params.id)
         *        await serveStatic(destination)
         *      })
         *    })
         * ```
         *
         * Note: Extracted params from express-style criteria are available as object under req.params.
         * When regular expression is used as path criteria, the matched group params are available as array under req.params.$.
         * Example: $1 => req.params.$[1]
         *
         * @param fn A function to run in the cloud to compute the response
         */
        this.compute = (fn) => {
            this.sendToServerless(constants_1.EDGIO_SERVERLESS_HINTS.compute, fn);
        };
        /**
         * Relays the request to the specified origin.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path/with/:variable', ({ proxy }) => {
         *      proxy('legacy', { path: '/some/other/path/with/:variable' })
         *    })
         * ```
         *
         * In this example, we relay the request to the "legacy" origin. In this case, `edgio.config.js` must
         * contain a definition for the `legacy` origin.  For example:
         *
         * ```
         *  // edgio.config.js
         *
         *  module.exports = {
         *    routes: "./routes.js",
         *    ...
         *    origins: [
         *       {
         *         name: 'legacy',
         *         balancer: 'round_robin',
         *         hosts: [{ location: 'legacy.domain.com' }],
         *       },
         *     ],
         *  }
         * ```
         *
         * @param backend The name of one of the origins in your `edgio.config.js` file.
         * @param options
         * @returns A promise the resolves once the response has been fetched from the upstream site.
         */
        this.proxy = (backend, options) => {
            this.setOrigin(backend);
            if ((options === null || options === void 0 ? void 0 : options.transformRequest) || (options === null || options === void 0 ? void 0 : options.transformResponse)) {
                // if either transformRequest or transformResponse are provided, we need to use serverless
                // since sailfish does not support these options
                this.sendToServerless(constants_1.EDGIO_SERVERLESS_HINTS.proxy, async (req, res, propertyContext) => {
                    // we know that lambdaresponse is used internally, just not exposed in compute api for users
                    const lambdaResponse = res;
                    (options === null || options === void 0 ? void 0 : options.transformRequest) && options.transformRequest(req);
                    // TODO: if we dont tranform response, we COULD stream the body chunk by chunk, but we dont have
                    // an access to requestcontext here so its moreso an idea for the future, as its an edge case
                    // if (!options?.transformResponse) {
                    //   lambdaResponse.setOnWrite(async () => await this.context.executeStreamResponse())
                    // }
                    await new OriginFetcher_1.default(propertyContext).fetch(req, res, {
                        headers: options === null || options === void 0 ? void 0 : options.headers,
                        removeEmptySearchParamValues: options === null || options === void 0 ? void 0 : options.removeEmptySearchParamValues,
                        path: options === null || options === void 0 ? void 0 : options.path,
                    }, backend);
                    // we create body from received chunks, so users can further transform it in transformResponse
                    // the ending chunk is always null, therefore we omit it, otherwise the buffer wont be able to concat
                    lambdaResponse.body = Buffer.concat(lambdaResponse.chunks.slice(0, -1));
                    // if we dont transform response, the chunks are already in proper format at this time
                    if (options === null || options === void 0 ? void 0 : options.transformResponse) {
                        options.transformResponse(res, req);
                        res.setHeader('Content-Length', lambdaResponse.body.length.toString());
                    }
                });
            }
            else if (options) {
                // otherwise we can transform the request at the edge using features
                if (options.path) {
                    const destination = typeof options.path === 'string' ? options.path : options.path();
                    // If path is an array (InOperatorValues), we use match all as a path
                    // as we cannot know which path will be used, so whatever is matched pass it to the origin
                    // otherwise if it is.
                    // Matching against negation doesnt make sense.
                    const path = Array.isArray(this.routeCriteria.path) || (0, RouteCriteria_1.isNegation)(this.routeCriteria.path)
                        ? '/:path*'
                        : this.routeCriteria.path;
                    if (destination) {
                        this.rewritePath(path, destination);
                    }
                }
                if (options === null || options === void 0 ? void 0 : options.headers) {
                    for (const [key, value] of Object.entries(options.headers)) {
                        this.setRequestHeader(key, value);
                    }
                }
                if ((options === null || options === void 0 ? void 0 : options.followRedirects) != null) {
                    if (!this.features.url)
                        this.features.url = {};
                    this.features.url.follow_redirects = options === null || options === void 0 ? void 0 : options.followRedirects;
                }
            }
        };
        /**
         * Adds or replaces existing response header
         * immediately before delivering the response downstream.
         * New value can be appended to the end of existing value by prepending a `+` symbol to the header name.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ setResponseHeader, proxy }) => {
         *      proxy('origin')
         *      setResponseHeader('new-header', 'some-value')
         *      setResponseHeader('+existing-header', 'other-value')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the response header
         * @param value The value to set
         */
        this.setResponseHeader = (name, value) => {
            /* istanbul ignore else */
            if (!this.features.headers) {
                this.features.headers = {};
            }
            /* istanbul ignore else */
            if (!this.features.headers.set_response_headers) {
                this.features.headers.set_response_headers = {};
            }
            const headers = this.features.headers.set_response_headers;
            headers[name] = value;
        };
        /**
         * Adds new response header without replacing existing headers with the same name
         * before delivering the response downstream.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ addResponseHeader, proxy }) => {
         *      proxy('origin')
         *      addResponseHeader('some-header', 'some-value')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the response header
         * @param value The value to set
         */
        this.addResponseHeader = (name, value) => {
            /* istanbul ignore else */
            if (!this.features.headers) {
                this.features.headers = {};
            }
            /* istanbul ignore else */
            if (!this.features.headers.add_response_headers) {
                this.features.headers.add_response_headers = {};
            }
            const headers = this.features.headers.add_response_headers;
            headers[name] = value;
        };
        /**
         * Alters a response header immediately before delivering the response downstream.
         * Use this method to derive the new header value from the existing one.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ updateResponseHeader, proxy }) => {
         *      proxy('origin')
         *      updateResponseHeader('some-header', /some-.*-part/gi, 'some-replacement')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the response header
         * @param match Regex to find the part that should be replaced.
         * @param replace Value that will replace the matched part.
         */
        this.updateResponseHeader = (name, match, replace) => {
            // Creates Find And Replace interpolation expression from the given regex and replacement string
            this.setResponseHeader(name, `%{resp_${name}/${match.global ? '/' : ''}${(0, toEdgeRegex_1.default)(match)}/${replace}}`);
        };
        /**
         * Removes a response header immediately before delivering the response downstream.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ removeResponseHeader, proxy }) => {
         *      proxy('origin')
         *      removeResponseHeader('some-header')
         *    })
         * ```
         * @param name The case-insensitive name of the response header
         */
        this.removeResponseHeader = (name) => {
            /* istanbul ignore else */
            if (!this.features.headers) {
                this.features.headers = {};
            }
            if (!this.features.headers.remove_response_headers) {
                this.features.headers.remove_response_headers = [];
            }
            this.features.headers.remove_response_headers.push(name);
        };
        /**
         * Removes a header from the response provided by an origin server.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ removeUpstreamResponseHeader, proxy }) => {
         *      proxy('origin')
         *      removeUpstreamResponseHeader('some-header')
         *    })
         * ```
         * @param name The case-insensitive name of the response header
         */
        this.removeUpstreamResponseHeader = (name) => {
            /* istanbul ignore else */
            if (!this.features.headers) {
                this.features.headers = {};
            }
            if (!this.features.headers.remove_origin_response_headers) {
                this.features.headers.remove_origin_response_headers = [];
            }
            this.features.headers.remove_origin_response_headers.push(name);
        };
        /**
         * Adds or replaces a request header.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ setRequestHeader, proxy }) => {
         *      setRequestHeader('some-header', 'some-value')
         *      proxy('origin')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the request header
         * @param value The value to set
         */
        this.setRequestHeader = (name, value) => {
            /* istanbul ignore else */
            if (!this.features.headers) {
                this.features.headers = {};
            }
            /* istanbul ignore else */
            if (!this.features.headers.set_request_headers) {
                this.features.headers.set_request_headers = {};
            }
            const headers = this.features.headers.set_request_headers;
            headers[name] = value;
        };
        /**
         * Alters a request header. Use this method to derive the new header value from the existing one.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ updateRequestHeader, proxy }) => {
         *      updateRequestHeader('some-header', /some-.*-part/gi, 'some-replacement')
         *      proxy('origin')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the request header
         * @param match Regex to find the part that should be replaced.
         * @param replace Value that will replace the matched part.
         */
        this.updateRequestHeader = (name, match, replace) => {
            // Creates Find And Replace interpolation expression from the given regex and replacement string
            this.setRequestHeader(name, `%{http_${name}/${match.global ? '/' : ''}${(0, toEdgeRegex_1.default)(match)}/${replace}}`);
        };
        /**
         * Adds or replaces a response body. It optionally sets response code or message.
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ setResponseBody }) => {
         *      setResponseBody('<html><body>Hello World!</body></html>', 200, 'OK')
         *    })
         * ```
         *
         * @param body The response body.
         * @param code The response code.
         * @param done Indicates that this is last feature
         */
        this.setResponseBody = (body, code, done) => {
            if (!this.features.response) {
                this.features.response = {};
            }
            this.features.response.set_done = !!done;
            this.features.response.set_response_body = body;
            if (code)
                this.features.response.set_status_code = code;
        };
        /**
         * Adds or replaces a response code.
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ setResponseCode, proxy }) => {
         *      setResponseCode(200)
         *      proxy('origin')
         *    })
         * ```
         *
         * @param code The response code.
         */
        this.setResponseCode = (code) => {
            if (!this.features.response) {
                this.features.response = {};
            }
            this.features.response.set_status_code = code;
        };
        /**
         * Sends the necessary response headers to allow CORS.
         *
         * **Example**
         *
         * ```js
         *  new Router()
         *    .match('/api/:path*', ({ allowCors }) => {
         *      allowCors({
         *        origin: '*', // this is the default
         *        methods: ['get', 'post'],
         *        headers: ['x-some-header'],
         *        maxAge: 60 * 60, // one hour
         *        credentials: true
         *      })
         *    })
         * ```
         *
         * @param config
         */
        this.allowCors = (config = {}) => {
            this.setResponseHeader('Access-Control-Allow-Origin', config.origin || '*');
            if (config.methods) {
                this.setResponseHeader('Access-Control-Allow-Methods', config.methods.join(', '));
            }
            if (config.headers) {
                this.setResponseHeader('Access-Control-Allow-Headers', config.headers.join(', '));
            }
            if (config.maxAge) {
                this.setResponseHeader('Access-Control-Max-Age', config.maxAge.toString());
            }
            if (config.credentials != null) {
                this.setResponseHeader('Access-Control-Allow-Credentials', config.credentials.toString());
            }
        };
        /**
         * Adds a path_rewrite feature using path-to-regexp syntax for the source and destination
         * @param source
         * @param destination
         * @param skipOptionalQuery
         * @private
         */
        this.rewritePath = (source, destination, skipOptionalQuery) => {
            /* istanbul ignore else */
            if (!this.features.url) {
                this.features.url = {};
            }
            /* istanbul ignore else */
            if (!this.features.url.url_rewrite) {
                this.features.url.url_rewrite = [];
            }
            // Convert ExactPath to string to
            // allow CriteriaPath to be used as source.
            if (source instanceof exact_1.ExactPath) {
                source = source.toString();
            }
            if (typeof source === 'string') {
                // When source is string, we can assume that the user wants to use the path-to-regexp syntax with support for named parameters.
                this.features.url.url_rewrite.push((0, path_1.rewritePath)(source, destination, skipOptionalQuery));
            }
            else {
                // The user will have to write substitution groups in destination by themselves when regex is used as source.
                this.features.url.url_rewrite.push({
                    syntax: 'regexp',
                    source: source ? (0, toEdgeRegex_1.default)(source) : undefined,
                    destination,
                });
            }
        };
        /**
         * Rewrites the request path.
         *
         * Example:
         *
         * ```js
         *  router.get('/products/:id', ({ updatePath }) => {
         *    updatePath('/p/:id')
         *  })
         * ```
         *
         * The substitution group params can be used in the asset path when path criteria is Regular Expression.
         * The same functionality can be achieved using the code below.
         *
         * ```js
         *  new Router()
         *    .get(/\/products\/(.+)/, ({ updatePath }) => {
         *      updatePath('/p/$1')
         *    })
         * ```
         *
         * @param destination a new route path, which can include params captured from the original path
         */
        this.updatePath = (destination) => {
            var _a;
            // params should be extracted by the latest path rule
            this.paramsExtractor.updateRouteCriteria({
                path: destination,
            });
            this.rewritePath((_a = this.routeCriteria.path) !== null && _a !== void 0 ? _a : '/:path*', destination);
        };
        /**
         * Sends string content back to client. If content is a string, the response will be sent
         * directly from the edge. If it is a function, the request will be computed by a JavaScript worker.
         * StatusCode defaults to 200. On error routes we send the status code
         * as null, since we need to preserve the status code of the failed request unless it is provided.
         * @param content The content to send to the browser
         * @param statusCode The HTTP status code.
         * @param statusMessage The HTTP status message
         */
        this.send = (content, statusCode) => {
            if (typeof content === 'function') {
                this.compute(async (req, res) => {
                    res.body = content();
                    res.statusCode = statusCode;
                });
                return;
            }
            this.setResponseBody(content, statusCode, true);
        };
        /**
         * Removes a request header.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', async ({ removeRequestHeader, proxy }) => {
         *      removeRequestHeader('some-header')
         *      proxy('origin')
         *    })
         * ```
         * @param name The case-insensitive name of the request header
         */
        this.removeRequestHeader = (name) => {
            // create empty object when no object exists
            this.features.headers = !this.features.headers ? {} : this.features.headers;
            this.features.headers.set_request_headers = !this.features.headers.set_request_headers
                ? {}
                : this.features.headers.set_request_headers;
            // Removing header by setting it to empty (empty headers are not added to result) because there's no
            // remove_request_header option in schema?
            const headers = this.features.headers.set_request_headers;
            headers[name] = '';
        };
        /**
         * Serves an HTML app shell from a static file.
         * @param indexHtmlPath The path to the app shell html file
         *
         * **Example**
         *
         * ```js
         *  new Router()
         *    .fallback(({ appShell }) => {
         *      appShell('dist/index.html')
         *    })
         * ```
         */
        this.appShell = (indexHtmlPath) => {
            this.setResponseHeader(constants_2.HTTP_HEADERS.contentType, 'text/html');
            this.serveStatic(indexHtmlPath);
        };
        /**
         * Redirects the browser to a new location.
         * Query params from the original request are added to the redirect URL
         *
         * **Examples**
         *
         * ```
         *  new Router()
         *    .get('/p/:productId', ({ redirect }) => {
         *      return redirect('/products/:productId', { statusCode: 301 })
         *    })
         *.
         *  // The substitution group params can be used in the redirect location when path criteria is Regular Expression.
         *  new Router()
         *    .get(/\/p\/(.+)/, ({ redirect }) => {
         *      return redirect('/products/$1', { statusCode: 301 })
         *    })
         *
         *  // Extract id from route and apply as query string
         *  new Router()
         *    .get('/p/:productId', ({ redirect }) => {
         *      return redirect('/product', { query: { id: ':productId' }})
         *    })
         *
         *  new Router()
         *  .get(/\/p\/(\d+)\/?/, ({ redirect }) => {
         *      return redirect('/product', { query: { id: '$1' }})
         *    })
         *
         *  // Extract id from query string and apply to route
         *  new Router()
         *    .get({ path: '/p', query: { id: ':id' } }, ({ redirect }) => {
         *      return redirect('/product/:id')
         *    })
         * ```
         *
         * @param to The URL to which the browser will be redirected.
         * @param options
         * @param options.statusCode The HTTP status to return. Defaults to 302
         * @param options.query Key-value object of query strings to be added to the redirect url
         */
        this.redirect = (to, options = {}) => {
            var _a, _b, _c, _d, _e, _f;
            // query object contains query extracted from toPath and additional queries provided in options
            const { to: toPath, statusCode, query: query } = (0, RedirectOptions_1.normalizeRedirectOptions)(to, options);
            // we can use simple rewrite if query is used for matching only
            const isMatchOnlyQuery = () => {
                var _a;
                return !Object.values((_a = this.routeCriteria.query) !== null && _a !== void 0 ? _a : {}).find(value => typeof value === 'string' && value.startsWith(':'));
            };
            // Sailfish is matching url_redirect.source against the current request URL,
            // and not incoming URL. If there's any rewrite rule together with redirect (such as the one in serveStatic method),
            // the redirect is not matched. This is not how the old redirect method worked. The redirect("/dest/:path") would not work.
            // That's why we need to add this rewrite rule to the same URL.
            this.rewritePath('/:path*', '/:path*');
            // When there's no manipulation with request or response query,
            // we can bind params via regex on the Edge.
            // Otherwise, there's no way to backreference query matches during replace,
            // as they can be in any order, and the replace follows match order.
            if ((0, isEmpty_1.default)(query) && isMatchOnlyQuery()) {
                this.features.url = (_a = this.features.url) !== null && _a !== void 0 ? _a : {};
                this.features.url.url_redirect = (_b = this.features.url.url_redirect) !== null && _b !== void 0 ? _b : {};
                this.features.url.url_redirect.code = statusCode;
                // When path is provided as Regex there are no params in path to be extracted.
                // The user can use groups captured params in destination path.
                if (((_c = this.routeCriteria) === null || _c === void 0 ? void 0 : _c.path) instanceof RegExp) {
                    this.features.url.url_redirect.source = (0, toEdgeRegex_1.default)((_d = this.routeCriteria) === null || _d === void 0 ? void 0 : _d.path);
                    this.features.url.url_redirect.destination = toPath;
                    this.features.url.url_redirect.syntax = 'regexp';
                    return;
                }
                this.features.url.url_redirect = {
                    ...this.features.url.url_redirect,
                    ...(0, path_1.rewritePath)((_f = (_e = this.routeCriteria) === null || _e === void 0 ? void 0 : _e.path) === null || _f === void 0 ? void 0 : _f.toString(), toPath, true),
                };
                return;
            }
            // Complex redirects manipulating query string are delegated to compute and cached "for ever".
            // Cache key includes query string by default so every path / query string
            // combination is cached independently, which is what we want as redirects
            // location header includes original request's query string.
            this.sendToServerless(constants_1.EDGIO_SERVERLESS_HINTS.redirect, async (req, res) => {
                let queryWithReplacedParams = {};
                // Bind params to query key and values extracted from
                // redirect path and options
                for (const queryKey in query) {
                    queryWithReplacedParams = {
                        ...queryWithReplacedParams,
                        [(0, bindParams_1.default)(queryKey, req.params)]: (0, bindParams_1.default)(query[queryKey], req.params),
                    };
                }
                // Generate the final location by binding params to redirect path and
                // concatenating the original request query together with extracted query from
                // redirect path and options
                res.setHeader(constants_2.HTTP_HEADERS.location, `${(0, bindParams_1.default)(toPath, req.params)}${Object.keys(queryWithReplacedParams).length > 0
                    ? '?' + qs_1.default.stringify(queryWithReplacedParams)
                    : ''}`);
                res.statusCode = statusCode;
                res.body = '';
            });
            this.cache({
                cacheableStatusCodes: [301, 302, 305, 307, 308],
                edge: {
                    maxAgeSeconds: constants_1.FAR_FUTURE_TTL,
                },
            });
        };
        /**
         * Adds a `set-cookie` header to the response.
         * This does not replace any cookies with the same name - for that you should use `updateResponseCookie`.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ addResponseCookie, proxy }) => {
         *      proxy('origin')
         *      addResponseCookie('my-cookie', 'my-cookie-value', { domain: 'test.com' })
         *    })
         * ```
         *
         * @param name Name of the cookie to add.
         * @param value Value to set
         * @param options Optional options to add to cookie
         */
        this.addResponseCookie = (name, value, options) => {
            this.addResponseHeader(constants_2.HTTP_HEADERS.setCookie, (0, cookieUtils_1.serializeCookie)(name, value, options));
        };
        /**
         * Allows to change the origin that the request is proxied to.
         * This is useful when you want to proxy to a different origin based on the matched rule.
         * The origin set by the latest matched rule will be used.
         *
         * This method doesn't affect the proxy method.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/:path*', ({ setOrigin }) => {
         *      setOrigin('fallback_origin')
         *    })
         *    .get('/products/1', ({ setOrigin }) => {
         *      setOrigin('web_origin')
         *    })
         * ```
         *
         * @param name the origin name
         */
        this.setOrigin = (name) => {
            if (!this.features.origin)
                this.features.origin = {};
            this.features.origin.set_origin = name;
        };
        /**
         * Allows to set a comment feature on the rule, which will be displayed in the dashboard.
         * The comment message supports markdown.
         * @param message
         */
        this.setComment = (message, append = false) => {
            if (!append)
                this.features.comment = '';
            this.features.comment += message;
        };
        this.routeCriteria = criteria;
        this.paramsExtractor = new ParamsExtractor_1.default(criteria);
        this.router = router;
    }
    /**
     * Creates a Features instance by running the provided callback.
     * @private
     * @param creator
     * @returns
     */
    evaluate(creator) {
        creator(this);
        return this.features;
    }
    /**
     * Forwards the request to the serverless origin
     * @param hint
     * @param fn
     */
    sendToServerless(hint, fn) {
        const hintIndex = fn
            ? this.router.addFunction(async (req, res, propertyContext) => {
                // extract params matched by routeCriteria path, query matched by routeCriteria query
                // and add them to request for backward compatibility
                req.params = this.paramsExtractor.extract(req);
                // execute original compute function
                await fn(req, res, propertyContext);
            })
            : null;
        this.setRequestHeader(`+${constants_1.EDGIO_SERVERLESS_HINT_HEADER}`, hintIndex !== null ? `${hint}:${hintIndex}` : hint);
        // Remove the default origin and team prefix
        // RequestContext.executeApp will append the origin and team
        this.setOrigin(origins_1.SERVERLESS_ORIGIN_NAME);
    }
}
exports.default = RouteHelper;
