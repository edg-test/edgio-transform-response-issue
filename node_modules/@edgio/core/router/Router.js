"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.STATIC_ASSET_MANIFEST_FILE = void 0;
const path_1 = require("path");
const constants_1 = require("../constants");
const source_1 = require("../source");
const utils_1 = require("../utils");
const requireInternal_1 = __importDefault(require("../utils/requireInternal"));
const toRule_1 = require("./converters/toRule");
const toFeature_1 = require("./converters/toFeature");
const PreloadRequests_1 = __importDefault(require("./PreloadRequests"));
const exact_1 = require("../router/exact");
const environment_1 = require("../environment");
const slash_1 = __importDefault(require("slash"));
/**
 * The static asset manifest file name
 * @private
 */
exports.STATIC_ASSET_MANIFEST_FILE = 'static-asset-manifest.json';
/**
 * The router is used to define routes and their associated features.
 */
class Router {
    constructor(options = {}) {
        this.rules = [];
        this.routerOptions = {};
        this.functions = [];
        this.preloadRequests = new PreloadRequests_1.default();
        /**
         * The contents to be written to static-asset-manifest.json, which is used to recreate
         * the paths for router.static(dir) when generating the rules for EdgeControl.
         * @private
         */
        this.staticAssetManifest = {};
        this.routerOptions = options;
    }
    addStaticAssetManifestEntry(path, data) {
        if (this.staticAssetManifest[path] === undefined) {
            this.staticAssetManifest[path] = data;
        }
        else {
            this.staticAssetManifest[path].push(...data);
        }
    }
    /**
     * Loads and returns a router from a file that exports it with `module.exports` or `export default`.
     * @param routerPath A path to routes.js,
     */
    static load(routerPath) {
        const routerModule = (0, utils_1.nonWebpackRequire)(routerPath);
        return (routerModule.default || routerModule);
    }
    /**
     * Defines a route that matches GET requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route.
     * @returns A self reference, suitable for chaining
     */
    get(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.get, criteria, features, options);
    }
    /**
     * Defines a route that matches POST requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    put(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.put, criteria, features, options);
    }
    /**
     * Defines a route that matches PATCH requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    patch(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.patch, criteria, features, options);
    }
    /**
     * Defines a route that matches POST requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    post(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.post, criteria, features, options);
    }
    /**
     * Defines a route that matches HEAD requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    head(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.head, criteria, features, options);
    }
    /**
     * Defines a route that matches DELETE requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    delete(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.delete, criteria, features, options);
    }
    /**
     * Defines a route that matches OPTIONS requests.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    options(criteria, features, options) {
        return this.matchMethod(constants_1.HTTP_METHODS.options, criteria, features, options);
    }
    /**
     * Defines a route.
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    match(criteria, features, options) {
        if (typeof criteria === 'string' ||
            criteria instanceof RegExp ||
            criteria instanceof exact_1.ExactPath) {
            return this.matchInternal({ path: criteria }, features, options);
        }
        else {
            return this.matchInternal(criteria, features, options);
        }
    }
    /**
     * Registers a rule that supports advanced if/then/else logic.
     * @param criteria
     * @returns A self reference, suitable for chaining
     */
    conditional(criteria) {
        this.rules.push(criteria);
        return this;
    }
    use(plugin) {
        plugin.onRegister(this);
        return this;
    }
    /**
     * Internal normalized method for adding a route.
     * @param criteria
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    matchInternal(criteria, featuresParam, options) {
        // convert to rule and add it internally
        const features = (0, toFeature_1.toFeature)(criteria, featuresParam, this);
        const rule = (0, toRule_1.toRule)(criteria, features);
        this.rules.push(rule);
        return this;
    }
    /**
     * Adds a route that matches the specific HTTP method and additional criteria.
     * @param method An HTTP method
     * @param criteria An express-style path expression, regular expression or advanced criteria object
     * @param features Features to apply when a request matches the route
     * @returns A self reference, suitable for chaining
     */
    matchMethod(method, criteria, features, options) {
        if (typeof criteria === 'string' ||
            criteria instanceof RegExp ||
            criteria instanceof exact_1.ExactPath) {
            return this.match({
                method,
                path: criteria,
            }, features);
        }
        if (criteria === null || criteria === void 0 ? void 0 : criteria.method) {
            throw new Error(`Invalid criteria property method passed to call to Router#${method}. Specifying a method in the criteria is redundant.`);
        }
        return this.match({ ...criteria, method }, features, options);
    }
    /**
     * Adds routes for all files in a directory tree.
     * @private
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param features A features that will be used to handle the matched files.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    dir(sourcePath, features, options = {}) {
        const createInMatcher = (files) => {
            // Don't create any rule if there are no files
            if (!files || files.length === 0)
                return;
            const paths = files
                .flatMap(file => { var _a; return ((_a = options === null || options === void 0 ? void 0 : options.paths) === null || _a === void 0 ? void 0 : _a.call(options, file)) || [`/${file}`]; })
                .flatMap(path => {
                if (!path.endsWith('/index.html'))
                    return [path];
                // Add additional paths for index.html files
                return Array.from(new Set([
                    // Add path with trailing slash
                    // Example: /folder/ for /folder/index.html
                    path.toString().replace(/\/index.html$/, '/'),
                    // Add path without trailing slash
                    // Example: /folder for /folder/index.html
                    path.toString().replace(/\/index.html$/, ''),
                ])).filter(path => path.length > 0);
            });
            this.match({ path: paths }, features);
        };
        if ((0, environment_1.isCloud)()) {
            const files = this.staticAssetsForPath(sourcePath);
            createInMatcher(files);
        }
        else {
            const files = Router.collectFiles(sourcePath, options);
            this.addStaticAssetManifestEntry((0, slash_1.default)(sourcePath), files);
            createInMatcher(files);
        }
        return this;
    }
    /**
     * Adds routes for all static assets in a directory tree.
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    static(sourcePath, options = {}) {
        const features = (helper) => {
            helper.serveStatic(`${sourcePath}/:path*`, {
                rewritePathSource: options === null || options === void 0 ? void 0 : options.rewritePathSource,
            });
            if (options === null || options === void 0 ? void 0 : options.handler)
                options.handler(helper);
        };
        return this.dir(sourcePath, features, options);
    }
    /**
     * Since the files are now on S3, we can no longer crawl the file system to
     * determine the routes, so we use the manifest file.
     * We also prevent webpack from trying to bundle the manifest, which will fail.
     */
    staticAssetsForPath(path) {
        return (0, utils_1.nonWebpackRequire)((0, path_1.join)(process.cwd(), exports.STATIC_ASSET_MANIFEST_FILE))[path];
    }
    /**
     * Registers a serverless function. Returns the index of the function being registered so that it can be called
     * at runtime based on the `x-edg-fn` request header.
     * @private
     * @param fn The serverless function to store
     * @returns the index of the function being registered
     */
    addFunction(fn) {
        this.functions.push(fn);
        return this.functions.length - 1;
    }
    /**
     * Adds preload config for router
     *
     * ```js
     *  new Router().prerender(
     *    async () => [{ path: '/foo', headers: { foo: 'bar' } }],
     *    [{ path: '/bar' }]
     *  )
     * ```
     *
     * @param preloadOptions
     */
    prerender(...preloadOptions) {
        this.preloadRequests.push(...preloadOptions);
        return this;
    }
    /**
     * Disables crawling of permalinks by setting the `x-robots-tag: noindex` response header
     * for hosts matching edgio.link or edgio-perma.link.
     *
     * ```js
     *  new Router().noIndexPermalink()
     * ```
     *   @deprecated Deprecated. Indexing permalinks is automatically disabled. Use `indexPermalink?: boolean` on Router Options to enable them.
     * * @returns {Router} A self-reference, suitable for chaining.
     */
    noIndexPermalink() {
        // The functionality of this function is automatically taken over
        // packages/core/src/router/addBuildInRoutes.ts
        return this;
    }
    static collectFiles(sourcePath, options) {
        var _a;
        const directory = (0, path_1.join)((0, source_1.getSourceDir)(), sourcePath);
        const ignore = typeof options.ignore === 'string' ? [options.ignore] : (_a = options.ignore) !== null && _a !== void 0 ? _a : [];
        // glob is large and we don't need it in production so we use nonWebpackRequire
        let files = (0, requireInternal_1.default)('globby').sync(options.glob || '**/*', {
            cwd: directory,
            onlyFiles: true,
            ignore,
        });
        if (options.sort) {
            files = options.sort(files);
        }
        return files;
    }
    /**
     * Adds a route that matches all requests that result in an error.
     *
     * Example:
     *
     * ```js
     *  new Router()
     *    .catch(/^(4|5)\d{2}$/, {
     *      // retry all 4xx and 5xx errors using the legacy origin
     *      retry: {
     *        origin: "legacy",
     *      },
     *    });
     * ```
     *
     * @param error A regular expression, string or number that matches the status code returned by the origin
     * @param features Features to apply when a request matches the route
     * @returns A self-reference, suitable for chaining.
     */
    catch(error, features) {
        let errorRegex;
        if (error instanceof RegExp) {
            errorRegex = error;
        }
        else {
            errorRegex = new RegExp(`^${error.toString()}$`);
        }
        return this.matchInternal({ response: { status_code: errorRegex } }, features);
    }
}
exports.default = Router;
