"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mapValues_1 = __importDefault(require("../utils/mapValues"));
const universalRouteUtils_1 = require("../utils/universalRouteUtils");
const CacheManifersRegexp_1 = require("./CacheManifersRegexp");
/**
 * A serializable array of route descriptors to be passed to the browser.
 * @private
 */
class CacheManifest {
    constructor(entries) {
        this.entries = entries || [];
    }
    /**
     * Returns a list of entries in this CacheManifest where both the browser and
     * edge cache times are defined, and greater than 0
     */
    get cacheableEntries() {
        return this.entries.filter(CacheManifest.isEntryCacheable);
    }
    /**
     * Returns a list of routes (as RegExp) that are cacheable SPA routes
     */
    get spaRoutes() {
        return this.cacheableEntries
            .filter(({ cacheOptions }) => cacheOptions.browser && cacheOptions.browser.spa)
            .map(({ route }) => new RegExp(route, 'i'));
    }
    /**
     * Returns true if the URL should be prefetched, based on the matched route's `cacheOptions`
     * @param url The URL to test
     */
    shouldPrefetch(url) {
        let doPrefetch = false;
        this.entries.some(entry => {
            const matches = CacheManifest.entryMatches(entry, url);
            if (matches) {
                doPrefetch =
                    CacheManifest.isEntryCacheable(entry) || !!entry.cacheOptions.prefetchUpstreamRequests;
                // if it's prefetchable, or if it matches a stop route, then no need to continue checking:
                return doPrefetch;
            }
            return false;
        });
        return doPrefetch;
    }
    /**
     * Returns true if the entry matches the URL's path, query params, and/or protocol
     * @param entry The entry to test
     * @param url URL to check against the entry
     */
    static entryMatches(entry, url) {
        const matchRoute = new RegExp(entry.route, 'i').test(url.pathname);
        if (!matchRoute)
            return false;
        const matchParams = (0, universalRouteUtils_1.matchCriteriaRegexObjectWithRequestObject)((0, mapValues_1.default)(entry.query || {}, value => value ? new CacheManifersRegexp_1.CacheManifestRegexp(value.value, 'i', value.isNot) : null), Object.fromEntries(Array.from(url.searchParams.entries())));
        if (!matchParams)
            return false;
        const matchProtocol = entry.protocol
            ? new CacheManifersRegexp_1.CacheManifestRegexp(entry.protocol.value, 'i', entry.protocol.isNot).test(url.protocol)
            : true;
        return matchProtocol;
    }
    /**
     * Returns true if the given entry has its `cacheOptions` set so that the route
     * is cacheable by the edge and the browser.
     * @param entry The entry to test
     */
    static isEntryCacheable({ cacheOptions }) {
        return !!(cacheOptions.browser &&
            (cacheOptions.browser.serviceWorkerSeconds || 0) > 0 &&
            cacheOptions.edge &&
            (cacheOptions.edge.maxAgeSeconds || 0) > 0);
    }
    /**
     * Creates a new `CacheManifest` object from the provided serialized entries
     */
    static fromEntries(entries) {
        return new CacheManifest(entries);
    }
    /**
     * Test a string against a pattern that may be negated
     */
    static matchRegex(pattern, value, regexOptions) {
        const res = new RegExp(pattern.value, regexOptions).test(value);
        return pattern.isNot === true ? !res : res;
    }
    /**
     * Serializes the list so that it can be passed to the browser
     */
    toJSON() {
        return JSON.stringify(this.entries);
    }
}
exports.default = CacheManifest;
