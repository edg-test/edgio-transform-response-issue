"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.watchEdgeFunctions = exports.getEdgeFunctionBytecode = void 0;
const path_1 = require("path");
const utils_1 = require("../../utils");
const edgeFunctionUtils_1 = require("../../utils/edgeFunctionUtils");
const EdgeFunctionsNodeBuilder_1 = __importDefault(require("./EdgeFunctionsNodeBuilder"));
const paths_1 = require("./paths");
const fs_1 = require("fs");
/**
 * Close functions for all files being actively watched for changes
 */
let watchers = [];
/**
 * Returns the compiled code for the edge function at the specified source path
 * If there are no edge functions or they have not been generated yet, returns undefined.
 * @returns
 */
function getEdgeFunctionBytecode(rules = []) {
    // Check if there are any edge function features at all.
    if (!(0, edgeFunctionUtils_1.containsEdgeFunctionFeature)(rules))
        return undefined;
    const path = (0, paths_1.getQuickJSBytecodePath)();
    if (!(0, fs_1.existsSync)(path)) {
        // The edge functions have not been generated yet and we cannot invoke the build
        // here which is an asynchronous operation. So we return undefined and the caller
        // will later ensure that the edge function is built.
        return undefined;
    }
    return (0, fs_1.readFileSync)(path);
}
exports.getEdgeFunctionBytecode = getEdgeFunctionBytecode;
/**
 * Watches for changes to all edge functions referenced by the specified rules and compiles them.
 * @param rules The router rules
 * @param routerSrcPath The path to the routes file relative to the root of the app
 */
async function watchEdgeFunctions(rules, routerSrcPath) {
    const edgeFunctionsBuilder = new EdgeFunctionsNodeBuilder_1.default(rules, routerSrcPath);
    const { watch } = (0, utils_1.nonWebpackRequire)('chokidar');
    clearWatchers();
    for (let feature of (0, edgeFunctionUtils_1.getEdgeFunctionFeatures)(rules)) {
        const srcPath = feature.edge_function;
        const baseDir = (0, path_1.dirname)(routerSrcPath);
        const srcPathAbsolute = (0, path_1.join)(process.cwd(), baseDir, srcPath);
        const watcher = watch(srcPathAbsolute, {
            atomic: true, // Automatically filters out artifacts that occur when using editors that use "atomic writes" instead of writing directly to the source file.
        });
        watcher.on('change', async () => {
            process.stdout.write(`> Bundling ${(0, path_1.basename)(srcPath)}... `);
            await edgeFunctionsBuilder.build();
            process.stdout.write(`done.\n`);
        });
        watchers.push(watcher);
    }
    process.stdout.write(`> Bundling edge functions... `);
    await edgeFunctionsBuilder.build();
    process.stdout.write(`done.\n`);
}
exports.watchEdgeFunctions = watchEdgeFunctions;
/**
 * Clears all watches for edge function files
 */
function clearWatchers() {
    for (let watcher of watchers) {
        watcher.close();
    }
    watchers = [];
}
