"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EdgeFunctionsBuilder_1 = __importDefault(require("./EdgeFunctionsBuilder"));
const fs_1 = require("fs");
const path_1 = require("path");
const esbuild_1 = require("esbuild");
const environment_1 = require("../../environment");
const EdgeFunctionCompiler_1 = require("../../runtime/edge-functions/EdgeFunctionCompiler");
const paths_1 = require("./paths");
const edgeFunctionUtils_1 = require("../../utils/edgeFunctionUtils");
/**
 * The edge functions builder for NodeJS environment.
 * This builder uses esbuild to bundle the index file, so it allows to use imports in edge functions.
 * This builder builds the index file 'edgeFunctionsIndexCodeTemplate' with sdk, edge functions and bundle it.
 * The index file is then compiled to QuickJS bytecode.
 */
class EdgeFunctionsNodeBuilder extends EdgeFunctionsBuilder_1.default {
    /**
     * @param rules The router rules
     * @param baseDir The base of the project directory
     */
    constructor(rules, baseDir) {
        super(rules);
        this.baseDir = (0, path_1.isAbsolute)(baseDir) ? baseDir : (0, path_1.join)(process.cwd(), (0, path_1.dirname)(baseDir));
    }
    /**
     * Returns the code with edge function import as string
     * which can later be inserted into edge functions map.
     * @returns
     */
    getFunctionCode(srcPath) {
        // Here we use a require('module/path') call instead of import * from 'module/path' to ensure that side effects
        // are only executed if the function is used. This may help reduce unexpected behavior
        // from side-effects caused by poorly written code.
        return `const ${this.functionDefaultExportName} = require(${JSON.stringify((0, path_1.join)(this.baseDir, srcPath))}).default;`;
    }
    /**
     * Returns the code of prebuilt the index code template from the file system.
     * @returns
     */
    async getIndexCodeTemplate() {
        return (0, fs_1.readFileSync)((0, path_1.join)(__dirname, this.indexCodeTemplateFilename), 'utf8');
    }
    /**
     * Bundles the generated index code into a single file bundle
     * and returns the bundled code
     * @returns
     */
    async bundleIndexCode(indexFilePath = (0, paths_1.getIndexPath)()) {
        const indexCode = await this.getIndexCode();
        (0, fs_1.writeFileSync)(indexFilePath, indexCode);
        // We bundle the index file to a single file bundle
        // so the all imports in edge functions are resolved and added to bundle.
        const { code: bundledIndexCode } = await this.bundle(indexFilePath);
        return bundledIndexCode;
    }
    /**
     * Builds all edge functions referenced by the specified rules and compiles them.
     * Returns a Buffer with the compiled bytecode for the edge functions index file
     * or undefined if there are no edge functions.
     * @param options Additional options with custom paths
     * @returns
     */
    async build(options = {}) {
        // Check if there are any edge function features at all.
        if (!(0, edgeFunctionUtils_1.containsEdgeFunctionFeature)(this.rules))
            return undefined;
        options.indexFilePath = options.indexFilePath || (0, paths_1.getIndexPath)();
        options.bytecodePath = options.bytecodePath || (0, paths_1.getQuickJSBytecodePath)();
        const bundledIndexCode = await this.bundleIndexCode(options.indexFilePath);
        const bytecode = await (0, EdgeFunctionCompiler_1.compileEdgeFunction)(bundledIndexCode);
        (0, fs_1.writeFileSync)(options.bytecodePath, bytecode);
        return bytecode;
    }
    /**
     * Bundles the edge functions index at the specified path into a single file bundle.
     * @param indexPath
     * @returns
     */
    async bundle(indexPath) {
        const esBuildOptions = {
            entryPoints: [indexPath],
            bundle: true,
            minify: (0, environment_1.isProductionBuild)(),
            // format: cjs, with mainFields: [ module, main] gives the same output as
            // platform: node, but without allowing NodeJs builtins like `url` to be imported.
            format: 'cjs',
            mainFields: ['module', 'main'],
            sourcemap: false,
            write: false, // output to memory instead of writing to disk
        };
        const result = await (0, esbuild_1.build)(esBuildOptions);
        let code = '';
        for (let out of result.outputFiles || []) {
            code += out.text;
        }
        return { code };
    }
    /**
     * Converts the edge function into cjs
     * @param code
     * @returns cjs
     */
    async convertToCjs(code) {
        const esTransformOptions = {
            minify: false,
            target: 'node16.0',
            format: 'cjs',
        };
        const result = await (0, esbuild_1.transform)(code, esTransformOptions);
        return result.code;
    }
}
exports.default = EdgeFunctionsNodeBuilder;
